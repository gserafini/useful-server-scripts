#!/bin/bash
# High-Performance IP Banning Script using IPSET and CSF.
# This script is designed for deployment via cron job to automate Web Application Firewall (WAF) 
# actions. It scans web server logs for a comprehensive set of malicious keywords and excessive 
# access attempts (e.g., failed wp-login, ModSecurity violations, shell file probing). 
# It utilizes IPSET for high-capacity, kernel-level blocking and manages a persistent, 
# rotatable ban list synchronized with the CSF firewall rules via csfpost.sh.
#
# NOTE: This script is intended to be run with root privileges (e.g., via root's cron job) 
#       and no longer contains redundant 'sudo' calls.

# --- Author and Repository ---
# Author: Gabriel Serafini / gserafini@gmail.com
# Repository: https://github.com/gserafini/useful-server-scripts
# -----------------------------

# --- Command Line Options ---
# The script can be run with the following utility flags instead of its default log-scanning mode:
# 1. --init: Initializes the IPSET table and adds the necessary firewall rules to /etc/csf/csfpost.sh. 
#    This must be run once before the cron job is activated.
# 2. --whitelist <IP>: Adds the specified IP address to /etc/csf/csf.allow, removes it from the 
#    IPSET ban list, and reloads CSF. (Requires setup)
# 3. --blacklist <IP>: Immediately adds the specified IP address to the IPSET ban list 
#    and the tracking file. It skips whitelisted IPs. (Requires setup)
# 4. --logs "<path1> <path2>": Overrides the default log paths to scan. (Used in cron job or manual runs).
# 5. --clear: **DANGER** Flushes all IPs from the live IPSET table and clears the tracking file.
# ----------------------------

# --- Script Collaboration Credit ---
# This script was collaboratively developed and refined with Gemini Advanced.
# For historical context and feature additions (--init, --whitelist, --logs),
# please refer to the following chat:
# [https://gemini.google.com/app/44e88278aba578b0](https://gemini.google.com/app/44e88278aba578b0)
# -----------------------------------

# --- CONFIGURATION VARIABLES ---
IP_SET_NAME="high_volume_bans"
# Tracking file includes the IP_SET_NAME for clarity
IP_TRACKING_FILE="/etc/csf/ipset_tracking_${IP_SET_NAME}.log" 
CSF_ALLOW_FILE="/etc/csf/csf.allow" 
CSF_DENY_FILE="/etc/csf/csf.deny" 
CSF_POST_FILE="/etc/csf/csfpost.sh" # Path to custom firewall rules
MAX_BANS=50000 
# UPDATED: Increased permanent ban capacity to 5000
MAX_PERMANENT_BANS=5000
MAX_VIOLATION_COUNT=20 # The threshold for permanent (do not delete) ban, now based on aggregated hits.

# DEFAULT LOG FILES: These are used if no --logs argument is provided.
DEFAULT_LOG_PATHS="/usr/local/apache/logs/apache_mainlog /usr/local/apache/domlogs /usr/local/apache/logs/error_log"
LOG_PATHS="" 

# Temporary file for IP aggregation across all keywords
TEMP_AGGREGATE_FILE=$(mktemp)
# Temporary file for unique aggregated IPs (used in the new progress logic)
TEMP_UNIQUE_IPS=$(mktemp)
# -------------------------------

# Function to safely validate an IP address format
validate_ip() {
    local ip=$1
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        return 0 
    else
        return 1 
    fi
}

# Function to determine the absolute path of iptables for rule generation
get_iptables_path() {
    # 🟢 PORTABLE FIX: Use command -v to find the absolute path, falling back to a common location.
    # This path is needed to write a reliable rule to csfpost.sh.
    local path
    path=$(command -v iptables 2>/dev/null || echo '/usr/sbin/iptables')
    
    if [ ! -x "$path" ]; then
        # If the determined path is not executable, try the secondary common path
        path=$(command -v iptables 2>/dev/null || echo '/sbin/iptables')
        if [ ! -x "$path" ]; then
            # If still not found, return an empty string to signal failure
            echo ""
            return 1
        fi # <-- Fixed shell syntax
    fi
    echo "$path"
    return 0
}

# Function to check if the high-volume ban system is fully set up
is_setup_complete() {
    # 1. Check if the tracking file exists
    if [ ! -f "$IP_TRACKING_FILE" ]; then
        return 1
    fi
    
    # 2. Check if the IPSET exists 
    if ! ipset list "$IP_SET_NAME" &> /dev/null; then
        return 1
    fi

    # 3. Check if the iptables DROP rule is in csfpost.sh
    local iptables_path
    iptables_path=$(get_iptables_path)
    if [ -z "$iptables_path" ]; then
        # Cannot determine iptables path, so we can't check/initialize the rule.
        return 1
    fi

    local iptables_rule_line="$iptables_path -A INPUT -m set --match-set $IP_SET_NAME src -j DROP"
    if [ ! -f "$CSF_POST_FILE" ] || ! grep -q "$iptables_rule_line" "$CSF_POST_FILE"; then
        return 1
    fi

    return 0
}

# Function to enforce setup or offer to initialize
ensure_setup() {
    if is_setup_complete; then
        return 0 # Setup is good, proceed
    fi

    echo " "
    echo "====================================================================="
    echo "⚠️  CRITICAL SETUP WARNING"
    echo "====================================================================="
    echo "The High-Volume Ban system is not properly initialized."
    echo "The required IPSET table ('$IP_SET_NAME') or configuration is missing."
    
    # Check if run interactively (tty check)
    if [ -t 0 ]; then
        echo " "
        echo "Do you want to run the initialization (./csf_ban_wp_login_attackers --init) now?"
        read -r -p "Type 'yes' to initialize, or 'no' to exit: " response
        
        if [[ "$response" =~ ^[Yy][Ee][Ss]$ ]]; then
            echo "Running initialization..."
            perform_init # This function exits upon completion
        else
            echo "Initialization skipped. Exiting. Please run the script with the --init flag manually."
            exit 1
        fi
    else
        echo " "
        echo "ACTION REQUIRED: Run the script manually with the --init flag:"
        echo "  $0 --init"
        echo " "
        echo "This script is running in a non-interactive environment (cron) and cannot proceed."
        exit 1
    fi
}


# Function to report the current ban counts
# NOTE: Accepts optional second argument for the number of IPs added in the current run
report_ban_counts() {
    local report_title="$1"
    local new_bans_count="${2:-0}"
    echo "--- 📊 $report_title ---"
    
    # 1. Count IPSET Bans (from the synchronized tracking file)
    local ipset_count=$(grep -v '^\s*$' "$IP_TRACKING_FILE" 2>/dev/null | wc -l)

    # 2. Count CSF.DENY Bans (excluding comments and blank lines)
    local csf_deny_count=$(grep -v '^#' "$CSF_DENY_FILE" 2>/dev/null | grep -v '^\s*$' | wc -l)

    echo "Total IPs in custom IPSET '$IP_SET_NAME': $ipset_count / $MAX_BANS"
    echo "Total IPs in CSF Deny File '$CSF_DENY_FILE': $csf_deny_count"
    
    # Display the count for the current run if provided
    if [ "$new_bans_count" -gt 0 ]; then
        echo "New IPs added to blacklist: $new_bans_count"
    fi
    echo "----------------------"
}

# Function to perform the blacklist action (Manual Ban)
perform_blacklist() {
    ensure_setup # Check for setup before executing
    
    local ip=$1
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    local country=""

    echo "--- 🔴 Blacklist Action: $ip ---"

    # 1. IP Validation
    if ! validate_ip "$ip"; then
        echo "Error: Invalid IP address format: $ip"
        exit 1
    fi

    # 2. Whitelist Check (Do not ban whitelisted IPs)
    if grep -q "^$ip[[:space:]]*" "$CSF_ALLOW_FILE"; then
        echo "IP $ip is **WHITELISTED** in $CSF_ALLOW_FILE. Skipping blacklist action."
        exit 0
    fi

    # 3. IPSET Status Check (Do not re-ban already banned IPs)
    if ipset test "$IP_SET_NAME" "$ip" &> /dev/null; then
        echo "IP $ip is already in ipset: $IP_SET_NAME. Skipping insertion."
        report_ban_counts "Post-Blacklist Report" 0 # Pass 0 new bans
        exit 0
    fi
    
    # 4. GEOIP Lookup 
    cmd="geoiplookup $ip 2>/dev/null | sed -n -e \"s/GeoIP Country Edition: //p\" | xargs -r -0"
    country=$(eval "$cmd")

    # 5. Message Construction and Limit Check
    local message="Manually blacklisted via --blacklist"
    
    local current_ban_count=$(wc -l < "$IP_TRACKING_FILE")
    if [ "$current_ban_count" -ge "$MAX_BANS" ]; then
        echo "WARNING: Ban limit ($MAX_BANS) reached. IP $ip will be added, but the oldest rotatable IP will be removed on the next cron run."
    fi

    message="$message ($country)"

    # 6. Add to IPSET (kernel-level blocking)
    if ipset add "$IP_SET_NAME" "$ip" -exist; then
        echo "Added $ip to ipset: $IP_SET_NAME."
    else
        echo "ERROR: Failed to add $ip to ipset. Check ipset utility and permissions."
        exit 1
    fi

    # 7. Add to Tracking File (for persistence and rotation)
    # 🟢 MODIFIED: Add timestamp to the manually blacklisted entry
    echo "$ip # [$timestamp] $message" | tee -a "$IP_TRACKING_FILE" > /dev/null
    echo "Added $ip to tracking file: $IP_TRACKING_FILE."
    
    report_ban_counts "Post-Blacklist Report" 1 # Pass 1 new ban
    exit 0
}


# Function to perform the whitelist action
perform_whitelist() {
    ensure_setup # Check for setup before executing
    
    local ip=$1
    local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
    local comment="# Added via script at $timestamp"

    echo "--- 🟢 Whitelist Action: $ip ---"

    # 1. Add to CSF.ALLOW (requires CSF reload)
    if ! grep -q "^$ip[[:space:]]*" "$CSF_ALLOW_FILE"; then
        echo "$ip $comment" | tee -a "$CSF_ALLOW_FILE" > /dev/null
        echo "Added $ip to $CSF_ALLOW_FILE."
    else
        echo "$ip is already present in $CSF_ALLOW_FILE."
    fi

    # 2. Remove from IPSET (instant effect)
    if ipset test "$IP_SET_NAME" "$ip" &> /dev/null; then
        ipset del "$IP_SET_NAME" "$ip"
        echo "Removed $ip from ipset: $IP_SET_NAME."
    else
        echo "$ip was not found in ipset: $IP_SET_NAME (no action taken)."
    fi

    # 3. Remove from IPSET Tracking File
    local line_number=$(grep -n "^$ip " "$IP_TRACKING_FILE" 2>/dev/null | cut -d: -f1 | head -1)
    if [ -n "$line_number" ]; then
        sed -i "${line_number}d" "$IP_TRACKING_FILE"
        echo "Removed $ip from tracking file: $IP_TRACKING_FILE (Line: $line_number)."
    else
        echo "$ip was not found in tracking file (no action taken)."
    fi

    # 4. Trigger CSF reload to apply the csf.allow change
    echo "Reloading CSF to apply $CSF_ALLOW_FILE changes..."
    /usr/sbin/csf -r

    echo "Whitelist action complete for $ip."
    
    report_ban_counts "Post-Whitelist Report" 0 # Pass 0 new bans
    exit 0
}

# Function to initialize IPSET and CSF rules
perform_init() {
    local ip_set_line="ipset create $IP_SET_NAME hash:ip maxelem $MAX_BANS -exist"

    # 1. Determine the portable iptables path
    local iptables_path
    iptables_path=$(get_iptables_path)
    if [ -z "$iptables_path" ]; then
        echo "ERROR: Cannot find a valid path for the iptables executable. Initialization cannot proceed."
        exit 1
    fi
    local iptables_rule_line="$iptables_path -A INPUT -m set --match-set $IP_SET_NAME src -j DROP"

    echo "--- 🛠️ Initialization Action ---"

    # 2. Create IPSET
    echo "1. Creating IPSET table: $IP_SET_NAME with max size $MAX_BANS..."
    ipset create "$IP_SET_NAME" hash:ip maxelem "$MAX_BANS" -exist
    if [ $? -eq 0 ]; then
        echo "IPSET '$IP_SET_NAME' created or already exists."
    else
        echo "ERROR: Failed to create ipset '$IP_SET_NAME'. Check ipset utility and permissions."
        exit 1
    fi

    # 3. Add IPSET creation command to csfpost.sh (ensures set is recreated on CSF restart)
    echo "2. Adding IPSET creation command to $CSF_POST_FILE..."
    if ! grep -q "$ip_set_line" "$CSF_POST_FILE"; then
        echo -e "\n# Rule added by $0 for high-volume IP banning\n$ip_set_line" | tee -a "$CSF_POST_FILE" > /dev/null
        echo "Added ipset creation command to $CSF_POST_FILE."
    else
        echo "IPSET creation command already exists in $CSF_POST_FILE."
    fi

    # 4. Add iptables DROP rule to csfpost.sh (ensures traffic is blocked)
    echo "3. Adding portable iptables DROP rule ($iptables_path) for IPSET to $CSF_POST_FILE..."
    if ! grep -q "$iptables_rule_line" "$CSF_POST_FILE"; then
        echo "$iptables_rule_line" | tee -a "$CSF_POST_FILE" > /dev/null
        echo "Added iptables rule to $CSF_POST_FILE."
    else
        echo "IPTables rule already exists in $CSF_POST_FILE."
    fi

    # 5. Create/Touch the tracking file
    echo "4. Ensuring tracking file $IP_TRACKING_FILE exists..."
    touch "$IP_TRACKING_FILE" || { echo "ERROR: Cannot create tracking file $IP_TRACKING_FILE"; exit 1; }
    echo "Tracking file is ready."

    # 6. Reload CSF to apply new csfpost.sh rules immediately
    echo "5. Reloading CSF to apply new rules..."
    /usr/sbin/csf -r
    
    echo "Initialization complete. The system is ready for the high-volume ban script to run."
    exit 0
}

# Function to completely flush the IPSET and clear the tracking file
perform_clear() {
    ensure_setup # Ensure the ipset is known before trying to flush
    
    echo "--- ⚠️  DANGER: FULL IPSET CLEAR ACTION ---"
    
    # 1. Flush the IPSET table (Clears kernel-level block list instantly)
    if ipset flush "$IP_SET_NAME"; then
        echo "Successfully flushed all entries from ipset: $IP_SET_NAME."
    else
        echo "ERROR: Failed to flush ipset '$IP_SET_NAME'. Check ipset utility and permissions."
        exit 1
    fi
    
    # 2. Clear the persistent tracking file
    if truncate -s 0 "$IP_TRACKING_FILE"; then
        echo "Successfully cleared all content from tracking file: $IP_TRACKING_FILE."
    else
        # Fallback if truncate is not available (e.g., system doesn't have it)
        > "$IP_TRACKING_FILE"
        if [ $? -eq 0 ]; then
            echo "Successfully cleared all content from tracking file: $IP_TRACKING_FILE (using redirection)."
        else
            echo "ERROR: Failed to clear tracking file '$IP_TRACKING_FILE'."
            exit 1
        fi
    fi

    # 3. Report
    echo "IPSET '$IP_SET_NAME' is now empty. All prior bans are removed."
    report_ban_counts "Post-Clear Report" 0
    exit 0
}


# --- COMMAND LINE ARGUMENT PARSING ---
TEMP_ARGS=$(getopt -o '' --long init,whitelist:,blacklist:,logs:,clear -n 'csf_ban_wp_login_attackers' -- "$@")
if [ $? != 0 ]; then echo "Terminating..." >&2; exit 1; fi
eval set -- "$TEMP_ARGS"

while true; do
  case "$1" in
    --init )
      perform_init # Function exits the script upon completion
      shift 1
      ;;
    --whitelist )
      IP_TO_WHITELIST="$2"
      if [ -z "$IP_TO_WHITELIST" ]; then
          echo "Error: --whitelist requires an IP address argument."
          exit 1
      fi
      if ! validate_ip "$IP_TO_WHITELIST"; then
          echo "Error: Invalid IP address format: $IP_TO_WHITELIST"
          exit 1
      fi
      perform_whitelist "$IP_TO_WHITELIST" # This calls ensure_setup inside
      shift 2
      ;;
    --blacklist )
      IP_TO_BLACKLIST="$2"
      if [ -z "$IP_TO_BLACKLIST" ]; then
          echo "Error: --blacklist requires an IP address argument."
          exit 1
      fi
      perform_blacklist "$IP_TO_BLACKLIST" # This calls ensure_setup inside and exits
      ;;
    --logs )
      LOG_PATHS="$2"
      shift 2
      ;;
    --clear )
      perform_clear # New function call
      shift 1
      ;;
    -- )
      shift
      break
      ;;
    * )
      break
      ;;
  esac
done

# If LOG_PATHS was not set via command line, use the default paths.
if [ -z "$LOG_PATHS" ]; then
    LOG_PATHS="$DEFAULT_LOG_PATHS"
fi
# --- END ARGUMENT HANDLING ---

# 0. ENSURE SETUP IS COMPLETE FOR MAIN LOGIC
ensure_setup

# Original keywords remain the same
declare -A keywords
keywords=(
  # --- RCE / LFI / SQL Injection Payload Indicators (New) ---
  ["1 php://filter"]="attempted Local File Inclusion (LFI) using php://filter wrapper"
  ["1 /etc/passwd"]="attempted file traversal/read of /etc/passwd"
  ["1 etc/passwd"]="attempted LFI payload without leading slash"
  ["1 /proc/self/cmdline"]="attempted read of system process info"
  ["1 union select"]="attempted SQL injection with UNION SELECT clause"
  ["1 base64_decode"]="attempted RCE using base64 encoded payload"
  ["5 wso.php"]="attempted access to a WSO or similar PHP web shell"

  # --- ModSecurity Violations (High Frequency) ---
  ["5 AH01797"]="error_log ModSecurity AH01797: client denied by server configuration"
  ["5 AH10244"]="error_log ModSecurity AH10244: invalid URI path"
  ["5 AH01071"]="error_log ModSecurity AH01071: Got error Primary script unknown - requesting missing php file"
  ["1 1234123440"]="error_log ModSecurity 1234123440: Access denied with code 406 - URL Encoding Abuse Attack Attempt"
  ["1 1234123438"]="error_log ModSecurity 1234123438: Access denied with code 400 - Proxy access attempt"
  ["1 941120"]="error_log ModSecurity 941120: Warning. Pattern match - XSS Filter - Category 2: Event Handler Vector"
  ["1 941130"]="error_log ModSecurity 941130: Warning. Pattern match - XSS Filter - Category 3: Attribute Vector"
  ["1 941160"]="error_log ModSecurity 941160: Pattern match - NoScript XSS InjectionChecker: HTML Injection"
  ["1 942270"]="error_log ModSecurity 942270: Pattern match - Looking for basic sql injection. Common attack string for mysql, oracle and others."
  ["1 933160"]="error_log ModSecurity 933160: Pattern match - PHP Injection Attack: High-Risk PHP Function Call Found"
  ["1 933150"]="error_log ModSecurity 933150: Pattern match - PHP Injection Attack: High-Risk PHP Function Name Found"
  ["5 1234123429"]="error_log ModSecurity 1234123429: Warning. Pattern match - Request Indicates an automated program explored the site"
  ["1 1234123443"]="error_log ModSecurity 1234123443: Access denied with code 400 - GET or HEAD requests with bodies"
  ["1 1234123415"]="error_log ModSecurity 1234123415: Access denied with code 406 - SQL Injection Attack"
  ["1 1234123448"]="error_log ModSecurity 1234123448: Access denied with code 501 - Remote File Access Attempt"

  # --- Config/Secret File Probing ---
  ["1 \.env"]=".env"
  ["1 \.git"]=".git"
  ["1 \.swp"]=".swp"
  ["1 /config.json"]="/config.json"

  # --- Known Shell/Backdoor Probing ---
  ["1 /0.php"]="/0.php"
  ["1 /sidwsi.php"]="/sidwsi.php"
  ["1 /wp-includes/css/chosen.php"]="/wp-includes/css/chosen.php"
  ["1 /wp-admin/css/colors/install.php"]="/wp-admin/css/colors/install.php"
  ["1 /h.php"]="/h.php"
  ["1 /wp-includes/mani.php"]="/wp-includes/mani.php"
  ["1 /components/lig.php"]="/components/lig.php"
  ["1 /worksec.php"]="/worksec.php"
  ["1 /wp-content.php"]="/wp-content.php"
  ["1 /wp-admin/maint/min.php"]="/wp-admin/maint/min.php"
  ["1 /wp-content/uploads/chosen.php"]="/wp-content/uploads/chosen.php"
  ["1 /wp-content/plugins/fix/fai.php"]="/wp-content/plugins/fix/fai.php"
  ["1 /wp-admin/luuf.php"]="/wp-admin/luuf.php"
  ["1 /update/gely.php"]="/update/gely.php"
  ["1 alfacgiapi"]="alfacgiapi"
  ["1 shell.php.*404"]="shell.php and got 404 error code"
  ["1 upfile.php.*404"]="upfile.php and got 404 error code"
  ["1 mah.php"]="mah.php"
  ["1 /alfa-rex.php"]="/alfa-rex.php"
  ["1 minishell.php"]="minishell.php"
  ["1 alfashell.php"]="alfashell.php"
  ["1 mar.php"]="mar.php"
  ["1 /xp.php"]="/xp.php"
  ["1 /goods.php"]="/goods.php"
  ["1 /webdb.php"]="/webdb.php"
  ["1 byp.php"]="byp.php"
  ["1 file2.php.*404"]="file2.php and got 404 error code" 
  ["1 simple.php.*404"]="simple.php and got 404 error code"  
  ["1 bas.php.*404"]="bas.php and got 404 error code"
  ["1 bibil.php.*404"]="bibil.php and got 404 error code"
  ["1 auvt.php.*404"]="auvt.php and got 404 error code"
  ["1 ans.php.*404"]="ans.php and got 404 error code"
  ["1 0x.php.*404"]="0x.php and got 404 error code"
  ["1 gffbgfe.php"]="tried to access gffbgfe.php"
  ["1 install.php.*404"]="install.php and got 404 error code"
  ["1 ee.php.*404"]="ee.php and got 404 error code"
  ["1 /w.php"]="/w.php"
  ["1 /r.php"]="/r.php"
  ["1 /as.php"]="/as.php"
  ["1 ini.php.*404"]="ini.php and got 404 error code"
  ["1 /rk2.php"]="rk2.php"
  ["1 /bx.php"]="/bx.php"

  # --- Remote Management Probing ---
  ["1 /commpilot/"]="/commpilot/"
  ["1 /PhoneBackup/"]="/PhoneBackup/"
  ["1 /webtools/control/main"]="/webtools/control/main"
  ["1 /goform/formping"]="/goform/formping"
  ["1 wp-cXjq2.php"]="wp-cXjq2.php"
  ["1 UEP.php"]="UEP.php"
  
  # --- Archive/Download Probing ---
  ["1 old.rar.*404"]="old.rar and got 404 error code"
  ["1 old.jar.*404"]="old.jar and got 404 error code"
  ["1 old.7z.*404"]="old.7z and got 404 error code"
  
  # --- Brute Force / Scanning ---
  ["1 tools.ua.random"]="tools.ua.random user agent"
  ["1 /wordpresshp/wp-login.php?action=register"]="tried to register on our WordPress honeypot"
  ["100 wp-login"]="tried to access wp-login"
  ["5 wp-login.*500"]="wp-login and got 500 error code"
  ["20 wp-login.*403"]="wp-login and got 403 error code"
  ["5 wp-login.*404"]="wp-login and got 404 error code"
  ["5 xmlrpc.php.*404"]="xmlrpc.php and got 404 error code"
  ["30 /calendar/action~"]="Spidering calendars too hard when blocked by robots"
)

# --- EXECUTION START ---

echo " "
date

# Ensure temporary files are cleaned up on exit
trap "rm -f $TEMP_AGGREGATE_FILE $TEMP_UNIQUE_IPS" EXIT

# 1. INITIAL REPORTING (Reflects state before any changes in this run)
report_ban_counts "Pre-Run Ban Report"

echo "--- 🧹 1. START: PROACTIVE WHITELIST CLEANUP (CSF Allow vs. IPSET Ban List) ---"

# Get the total number of lines for the progress counter
TOTAL_TRACKING_LINES=$(wc -l < "$IP_TRACKING_FILE")

# The cleanup logic is kept here for the regular cron job run.
awk -v ip_set_name=$IP_SET_NAME \
    -v tracking_file=$IP_TRACKING_FILE \
    -v allow_file=$CSF_ALLOW_FILE \
    -v total_lines=$TOTAL_TRACKING_LINES \
    '
    BEGIN {
        print "Checking " total_lines " entries against " allow_file "..." > "/dev/stderr"
        processed = 0
    }
    {
        processed++
        
        # Print a simple progress bar/counter every 1000 lines (or when starting/finishing) to stderr
        if (total_lines > 0 && (processed % 1000 == 0 || processed == total_lines)) {
            printf "Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr"
        }
        
        ip_to_check = $1
        # Check if the IP is in csf.allow (Returns 0 if IP IS found)
        is_whitelisted = system("grep -E \"^" ip_to_check "[[:space:]]*#|^" ip_to_check "[[:space:]]*$\" " allow_file " > /dev/null 2>&1")

        if (is_whitelisted == 0) {
            # IP is whitelisted! Remove from ipset and print a message to stderr.
            system("ipset del " ip_set_name " " ip_to_check)
            print "CLEANED: Removed whitelisted IP " ip_to_check " from ipset." > "/dev/stderr"
        } else {
            # IP is not whitelisted. Print the line back to stdout for the new tracking file.
            print $0
        }
    }
    END {
        if (total_lines > 0) {
            # Print final status update with a newline
            printf "Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr"
        }
    }' "$IP_TRACKING_FILE" > /tmp/ipset_tracking_new.log

if [ -f /tmp/ipset_tracking_new.log ]; then
    mv /tmp/ipset_tracking_new.log "$IP_TRACKING_FILE"
    echo "Tracking file updated. Whitelisted IPs removed from the blacklist."
else
    echo "WARNING: Cleanup failed to produce a new tracking file. Skipping file replacement."
fi

echo "--- 🧹 1. END: PROACTIVE WHITELIST CLEANUP ---"
echo " "


# --- 🛡️ 2. START: LOG SCANNING (EXTRACTION PHASE) ---
echo "--- 🛡️ 2. START: LOG SCANNING (EXTRACTION PHASE) ---"
echo "Log paths being scanned: $LOG_PATHS"

# --- NEW: Get the total number of keywords for the progress counter ---
TOTAL_KEYWORDS=${#keywords[@]}
KEYWORD_COUNT=0
echo "Scanning for $TOTAL_KEYWORDS malicious keywords..."

# Phase 1: Scan all logs for all keywords and populate the temporary file.
for key in "${!keywords[@]}"; do
    KEYWORD_COUNT=$((KEYWORD_COUNT + 1))
    
    # 🟢 NEW: Progress update for the current keyword. Sent to stderr so it does not interrupt the pipeline.
    # We strip the frequency from the keyword for a cleaner visual status.
    current_keyword=$(echo "${key}" | cut -d" " -f2)
    echo "[$KEYWORD_COUNT/$TOTAL_KEYWORDS] Scanning logs for keyword: '${current_keyword}'" > /dev/stderr

    # Frequency is the MINIMUM count to be interested in for this specific keyword
    frequency=$(( $( echo ${key} | cut -d" " -f1) ))
    keyword=$( echo ${key} | cut -d" " -f2)
    description=${keywords[${key}]}

    # Pipe output for the current keyword. Output format: IP<tab>Count<tab>Description
    eval grep -r "$keyword" $LOG_PATHS 2>/dev/null |
    egrep -o '[ :][[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}' |
    sed 's/://' |
    sort | 
    uniq -c |
    awk -v frequency=$frequency \
        -v description="$description" '
    { 
      # Only output if the count for this specific keyword meets the minimum threshold
      if ($1 >= frequency ) {
        # Format: IP<TAB>Count<TAB>Description (e.g., 1.2.3.4\t20\twp-login)
        print $2 "\t" $1 "\t" description 
      }
    }' | tee -a "$TEMP_AGGREGATE_FILE"
done


if [ ! -s "$TEMP_AGGREGATE_FILE" ]; then
    echo "No significant violations found that meet minimum frequency thresholds."
    echo "--- 🛡️ 2. END: LOG SCANNING (EXTRACTION PHASE) ---"
    echo " "
    report_ban_counts "Post-Run Ban Report (No Bans)" 0
    exit 0
fi

echo "All relevant violations recorded. Starting aggregation and execution..."

# --- 🛡️ 2.1: Aggregation Phase (AWK 1) ---
# Aggregate the data to a temporary file for counting.
# Format: IP<SPACE>Total_Count<SPACE>Concatenated_Message
echo "Aggregating all violation counts to find unique IPs..." > /dev/stderr

awk '
BEGIN { 
    FS="\t" 
} 
{ 
    # Sum counts and concatenate descriptions for each IP
    IPs[$1] += $2; 
    
    # Check if description tag already exists before appending
    if (messages[$1] !~ $3) {
        messages[$1] = (messages[$1] == "" ? $3 : messages[$1] ", " $3);
    }
} 
END { 
    # Print aggregated results for the next awk block
    for (ip in IPs) { 
        print ip, IPs[ip], messages[ip] 
    } 
}' "$TEMP_AGGREGATE_FILE" > "$TEMP_UNIQUE_IPS"

TOTAL_UNIQUE_IPS=$(wc -l < "$TEMP_UNIQUE_IPS")
echo "Total unique IPs detected for action: $TOTAL_UNIQUE_IPS" > "/dev/stderr"

# --- 🛡️ 2.2: Execution Phase (AWK 2) with Progress Bar ---
# LOG_SCAN_OUTPUT captures all ban messages, rotation info, but excludes progress bar output
LOG_SCAN_OUTPUT=$(
    awk -v total_ips="$TOTAL_UNIQUE_IPS" \
        -v current_date="$(date '+%Y-%m-%d %H:%M:%S')" \
        -v ip_set_name=$IP_SET_NAME \
        -v tracking_file=$IP_TRACKING_FILE \
        -v allow_file=$CSF_ALLOW_FILE \
        -v max_bans=$MAX_BANS \
        -v max_perm_bans=$MAX_PERMANENT_BANS \
        -v max_violation_count=$MAX_VIOLATION_COUNT '
    BEGIN {
        processed = 0
    }
    {
      ip=$1
      total_count=$2
      message_summary=$3
      
      # PROGRESS BAR LOGIC: Update on every 10th IP or at the start/end
      processed++
      if (total_ips > 0 && (processed % 10 == 0 || processed == 1 || processed == total_ips)) {
          # Print to stderr for live, overwriting output (\r)
          printf "Processing bans: %d of %d (%.2f%%)\r" , processed, total_ips, (processed / total_ips * 100) > "/dev/stderr"
      }
      
      # 1. WHITELIST CHECK: (Redundant check but safer)
      is_whitelisted = system("grep -E \"^" ip "[[:space:]]*#|^" ip "[[:space:]]*$\" " allow_file " > /dev/null")
      if (is_whitelisted == 0) {
        print "IP " ip " is WHITELISTED in " allow_file ". Skipping ban (Proactively Cleaned)."
        print " "
        next 
      }
      
      # 2. IPSET STATUS CHECK: Check if IP is already in the set
      # 🟢 FIXED: Redirecting stderr (2) to /dev/null to silence the "is NOT in set" message
      is_already_banned = system("ipset test " ip_set_name " " ip " 2>/dev/null")
      if (is_already_banned == 0) {
        print "IP " ip " is already in ipset \047" ip_set_name "\047. Skipping insertion."
        print " "
        next 
      }
      
      # 3. GEOIP Lookup and Message Construction
      cmd="geoiplookup " ip " 2>/dev/null | sed -n -e \"s/GeoIP Country Edition: //p\" | xargs -r -0"
      cmd | getline country
      close(cmd)  

      "grep -c \"do not delete\" " tracking_file " | head -1" | getline permanent_ban_count
      close("grep -c \"do not delete\" " tracking_file " | head -1")

      is_new_ban_permanent = 0
      
      # The BAN MESSAGE now includes the concatenated summary and total count
      message="Total Violations: " total_count ". Triggers: " message_summary
      
      # PERMANENT BAN LOGIC: Based on TOTAL aggregated count
      if (total_count >= max_violation_count && permanent_ban_count < max_perm_bans) {
        protection_text = " [More than " max_violation_count " blocks, do not delete ]"
        message = message protection_text
        is_new_ban_permanent = 1
        print "IP qualifies for permanent ban. Current permanent count: " permanent_ban_count
      } else if (total_count >= max_violation_count) {
        print "IP qualifies for permanent ban, but permanent limit (" max_perm_bans ") reached. Appending as rotatable entry."
      }
      
      message = message " (" country ")"
      print "Blocking " ip " because " message

      # 4. Check Current Total Ban Count (Rotation Logic)
      "wc -l < " tracking_file | getline current_ban_count
      close("wc -l < " tracking_file)

      line_to_delete = 0
      delete_type = "none"
      
      if (current_ban_count >= max_bans) {
        print "Total ban limit (" max_bans ") reached. Checking for oldest rotatable entry."
        
        "grep -n -v \"do not delete\" " tracking_file " | head -1 | cut -d: -f1" | getline line_to_delete
        close("grep -n -v \"do not delete\" " tracking_file " | head -1 | cut -d: -f1")

        if (line_to_delete > 0) {
          delete_type = "rotatable"
        } else {
          if (is_new_ban_permanent == 1 && permanent_ban_count >= max_perm_bans) {
            print "WARNING: Total ban limit hit and all entries are permanent. Rotating oldest PERMANENT entry to make room."
            
            "grep -n \"do not delete\" " tracking_file " | head -1 | cut -d: -f1" | getline line_to_delete
            close("grep -n \"do not delete\" " tracking_file " | head -1 | cut -d: -f1")
            delete_type = "permanent"
          }
        }
      }

      # 5. EXECUTE DELETION if a line number was found
      if (line_to_delete > 0) {
        # FIXED: Using awk with octal quote (\047) to robustly extract the first field (IP)
        cmd_get_ip = "sed -n " line_to_delete "p " tracking_file " | awk \047{print $1}\047"
        cmd_get_ip | getline ip_to_delete
        close(cmd_get_ip)

        if (ip_to_delete) {
          system("ipset del " ip_set_name " " ip_to_delete)
          print "DELETED oldest " delete_type " IP from ipset: " ip_to_delete

          system("sed -i " line_to_delete "d " tracking_file)
        }
      } 
      
      # 6. INSERTION: Add the new IP to the ipset and tracking file
      system("ipset add " ip_set_name " " ip " -exist")
      # Use a unique marker for counting in the final report
      print "INSERTED new IP to ipset: " ip
      # 🟢 MODIFIED: Prepend the date to the message when writing to the file
      system("echo \"" ip " # [" current_date "] " message "\" >> " tracking_file) 

      print " "
    }
    END {
        if (total_ips > 0) {
             # Print final status update with a newline
             printf "Processing bans: %d of %d (100.00%%) - Complete.\n" , total_ips, total_ips > "/dev/stderr"
        }
    }' "$TEMP_UNIQUE_IPS"
)

# Count the number of new IPs inserted from the captured output
NEW_BANS_COUNT=$(echo "$LOG_SCAN_OUTPUT" | grep -c "INSERTED new IP to ipset:")

# Display the captured output to the user
echo "$LOG_SCAN_OUTPUT"

echo "--- 🛡️ 2. END: LOG SCANNING AND IPSET BANNING ---"
echo " "
echo "--- 🧹 3. FINALIZING ---"

# 3. FINAL REPORTING (Reflects state after changes in this run)
report_ban_counts "Post-Run Ban Report" "$NEW_BANS_COUNT"

# 🟢 NEW: Final tracking file message
echo "Banned IPs recorded in tracking file: $IP_TRACKING_FILE"

echo "Done!"
exit 0