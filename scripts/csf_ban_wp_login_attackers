#!/bin/bash
# High-Performance IP Banning Script using IPSET and CSF.
# This script is designed for deployment via cron job to automate Web Application Firewall (WAF) 
# actions.
# It scans web server logs for a comprehensive set of malicious keywords and excessive 
# access attempts (e.g., failed wp-login, ModSecurity violations, shell file probing).
# It utilizes IPSET for high-capacity, kernel-level blocking and manages a persistent, 
# rotatable ban list synchronized with the CSF firewall rules via csfpost.sh.
# NOTE: This script must be run with root privileges (e.g., via root's cron job)

# Prerequisites and important notes:
# - ipset and iptables must be available on the host and the script should be
#   initialized via the --init flag before enabling in cron (this sets up the
#   ipset table and the iptables match-set rule via CSF's csfpost.sh).
# - For immediate termination of already-established TCP sessions when an IP is
#   banned, install conntrack-tools (provides the `conntrack` command). When
#   conntrack is present, this script will delete conntrack entries for newly
#   banned IPs so those sessions are dropped immediately. If conntrack is not
#   installed, bans still apply to new connections but existing sessions may
#   persist until closed or timed out.
#   Example install commands:
#     RHEL/CentOS: sudo yum install -y conntrack-tools
#     Debian/Ubuntu: sudo apt-get install -y conntrack
# - RECOMMENDED: Install lsof for automatic PHP-FPM restart failure recovery.
#   When PHP-FPM restart fails due to lingering socket files (error: "Another FPM 
#   instance seems to already listen on..."), lsof is used to identify and kill 
#   the offending processes before retrying the restart. Without lsof, manual 
#   intervention may be required.
#   Example install commands:
#     RHEL/CentOS: sudo yum install -y lsof
#     Debian/Ubuntu: sudo apt-get install -y lsof
# - OPTIONAL: ModSecurity Integration - For INSTANT banning on first malicious request:
#   Run --install-mod-security-triggers to generate ModSecurity rules that set
#   the MALICIOUS_IP environment variable, which this script detects and immediately
#   bans without waiting for cron-based log scanning. This provides real-time
#   protection against critical threats like shell probes and SQL injection attempts.

# --- Author and Repository ---
# Author: Gabriel Serafini / gserafini@gmail.com
# Repository: https://github.com/gserafini/useful-server-scripts
# -----------------------------

# --- Command Line Options ---
# The script can be run with the following utility flags instead of its default log-scanning mode:
# 1. --init: Initializes the IPSET table and adds the necessary firewall rules to /etc/csf/csfpost.sh.
#    This must be run once before the cron job is activated.
# 2. --install-mod-security-triggers: Generates and optionally installs ModSecurity rules that trigger
#    IMMEDIATE IP banning on first malicious request via MALICIOUS_IP environment variable.
#    This bypasses the cron-based log scanning for instant protection against critical threats.
# 3. --whitelist <IP> [MESSAGE] / --unblock <IP> [MESSAGE]: Adds the specified IP address to /etc/csf/csf.allow,
#    removes it from the IPSET ban list, and reloads CSF.
#    The MESSAGE is optional but must be quoted if it contains spaces. (Requires setup)
# 4. --blacklist <IP> [MESSAGE] / --block <IP> [MESSAGE]: Immediately adds the specified IP address to the IPSET ban list
#    and the tracking file. It skips whitelisted IPs. The MESSAGE is optional but must be quoted if it contains spaces. (Requires setup)
# 5. --logs "<path1> <path2>": Overrides the default log paths to scan. (Used in cron job or manual runs).
# 6. --clear: **DANGER** Flushes all IPs from the live IPSET table and clears the tracking file.
#
# Additional reporting / abuse-evidence options (read-only):
# - --abuse-report <IP> [MIN_HITS]  (alias: --abuse)
#     Scans configured logs for the given IP and filters lines by the script's `keywords` list.
#     If the number of matched (keyword-related) lines >= MIN_HITS (default 100 or value set via --abuse-min),
#     the script prints a report and saves matched evidence to /tmp for copy/paste. This is read-only and will not
#     modify firewall state.
# - --abuse-min <N>
#     Set default minimum matched hits for abuse reports when MIN_HITS isn't supplied directly to --abuse-report.
# - --abuse-days <N>
#     Best-effort: attempt to restrict search to entries in the last N days (depends on your log timestamp formats).
# - --abuse-since <STRING> and --abuse-until <STRING>
#     Simple substring filters applied to log lines for a basic date-range filter (works for ISO dates or common formats).
# - --abuse-email
#     When present, attempt a minimal whois lookup to discover an abuse contact and print a draft abuse email (To:, Subject:, body with sample evidence).
#     Always manually verify any auto-discovered contact before sending.
# - --raw-grep <STRING>
#     Run a raw grep for the supplied string across all configured log files and print filename:line_num:line results.
#     This is read-only and will not modify firewall state. Alias: --raw-search
# ----------------------------

# --- Script Collaboration Credit ---
# This script was collaboratively developed and refined with Gemini Advanced.
# -----------------------------------

# --- CONFIGURATION VARIABLES ---
IP_SET_NAME="high_volume_bans"
IP_TRACKING_FILE="/etc/csf/ipset_tracking_${IP_SET_NAME}.log"
CSF_ALLOW_FILE="/etc/csf/csf.allow"
CSF_DENY_FILE="/etc/csf/csf.deny"
CSF_POST_FILE="/etc/csf/csfpost.sh" # Path to custom firewall rules
MAX_BANS=50000
MAX_PERMANENT_BANS=5000
MAX_VIOLATION_COUNT=20 # The threshold for permanent (do not delete) ban, based on aggregated hits.
# DEFAULT LOG FILES: These are used if no --logs argument is provided.
DEFAULT_LOG_PATHS="/usr/local/apache/logs/apache_mainlog /usr/local/apache/domlogs /usr/local/apache/logs/error_log"
LOG_PATHS="" 

# Temporary files - initialized later only when needed for log scanning operations
# Creating them here was wasteful for --blacklist/--whitelist/--init calls
TEMP_AGGREGATE_FILE=""
TEMP_UNIQUE_IPS=""
TEMP_TRACKING_FILE=""
TEMP_GEOIP_MAPPING=""
TEMP_CACHE_EXTRACTION=""

# --- TIMING VARIABLE ---
START_TIME_CMD=$(date +%s)
START_TIME=${START_TIME_CMD}
# -------------------------------

# --- MODSECURITY INTEGRATION: CHECK FOR ENVIRONMENT VARIABLE ---
# If ModSecurity sets MALICIOUS_IP environment variable, immediately ban that IP
# This allows instant blocking before the cron-based log scan runs
if [ -n "$MALICIOUS_IP" ]; then
    # Execute blacklist function with ModSecurity context
    exec "$0" --blacklist "$MALICIOUS_IP" "ModSecurity triggered ban"
fi
# ---------------------------------------------------------------

# Function to safely validate an IP address format
validate_ip() {
    local ip=$1
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        return 0 
    else
        return 1 
    fi
}

# Function to determine the absolute path of iptables for rule generation
get_iptables_path() {
    local path
    local path_cmd
    
    path_cmd=$(command -v iptables 2>/dev/null || echo '/usr/sbin/iptables')
    path=${path_cmd}
    
    if [ ! -x "$path" ]; then
        
        path_cmd=$(command -v iptables 2>/dev/null || echo '/sbin/iptables')
        path=${path_cmd}
        
        if [ ! -x "$path" ]; then
            echo ""
            return 1
        fi
    fi
    echo "$path"
    return 0
}

# Function to check if the high-volume ban system is fully set up
is_setup_complete() {
    if [ ! -f "$IP_TRACKING_FILE" ]; then
        return 1
    fi
    if ! ipset list "$IP_SET_NAME" &> /dev/null; then
        return 1
    fi
    local iptables_path
    
    local path_cmd
    path_cmd=$(get_iptables_path)
    iptables_path=${path_cmd}
    
    if [ -z "$iptables_path" ]; then
        return 1
    fi
    local iptables_rule_line="$iptables_path -A INPUT -m set --match-set $IP_SET_NAME src -j DROP"
    if [ ! -f "$CSF_POST_FILE" ] || ! grep -q "$iptables_rule_line" "$CSF_POST_FILE"; then
        return 1
    fi
    return 0
}

# Function to enforce setup or offer to initialize
ensure_setup() {
    if is_setup_complete; then
        return 0
    fi

    echo " "
    echo "====================================================================="
    echo "âš ï¸  CRITICAL SETUP WARNING"
    echo "====================================================================="
    echo "The High-Volume Ban system is not properly initialized."
    if [ -t 0 ]; then
        echo " "
        echo "Do you want to run the initialization (./csf_ban_wp_login_attackers --init) now?"
        read -r -p "Type 'yes' to initialize, or 'no' to exit: " response
        
        if [[ "$response" =~ ^[Yy][Ee][Ss]$ ]]; then
            echo "Running initialization..."
            perform_init
        else
            echo "Initialization skipped. Exiting. Please run the script with the --init flag manually."
            exit 1
        fi
    else
        echo " "
        echo "ACTION REQUIRED: Run the script manually with the --init flag."
        echo "This script is running in a non-interactive environment (cron) and cannot proceed."
        exit 1
    fi 
}


# Function to report the current ban counts
report_ban_counts() {
    local report_title="$1"
    local new_bans_count="${2:-0}"
    local end_time="${3:-0}" 
    echo "--- ğŸ“Š $report_title ---"
    
    local ipset_count
    ipset_count=$(grep -cvE '^\s*$' "$IP_TRACKING_FILE" 2>/dev/null)
    ipset_count=${ipset_count:-0}

    local permanent_ban_count
    permanent_ban_count=$(grep -c "do not delete" "$IP_TRACKING_FILE" 2>/dev/null)
    permanent_ban_count=${permanent_ban_count:-0}

    local csf_deny_count
    csf_deny_count=$(grep -cE '^[0-9]' "$CSF_DENY_FILE" 2>/dev/null)
    csf_deny_count=${csf_deny_count:-0}

    local csf_allow_count
    csf_allow_count=$(grep -cE '^[0-9]' "$CSF_ALLOW_FILE" 2>/dev/null)
    csf_allow_count=${csf_allow_count:-0}


    echo "Total IPs in custom IPSET '$IP_SET_NAME': $ipset_count / $MAX_BANS"
    echo "Permanent IPs ('do not delete'): $permanent_ban_count / $MAX_PERMANENT_BANS"
    echo "Total IPs in CSF Deny File '$CSF_DENY_FILE': $csf_deny_count"
    echo "Total IPs in CSF Allow File '$CSF_ALLOW_FILE': $csf_allow_count"
    
    if [ "$new_bans_count" -gt 0 ]; then
        echo "New IPs added to blacklist: $new_bans_count"
    fi

    if [ "$end_time" -gt "$START_TIME" ]; then
        local elapsed_time=$((end_time - START_TIME))
        local minutes=$((elapsed_time / 60))
        local seconds=$((elapsed_time % 60))
        echo "Total Elapsed Time: ${minutes}m ${seconds}s"
    fi
    
    echo "----------------------"
}

# Function to kill lingering php-fpm processes holding socket files
# This is called when php-fpm restart fails due to "Another FPM instance seems to already listen" errors
# Based on manual recovery: force remove sockets first, then killall -9, then targeted cleanup
kill_lingering_phpfpm_processes() {
    local php_version="$1"  # Optional: e.g., "74", "81", "82"
    local killed_count=0
    local actions_taken=0

    echo "ğŸ” Aggressively cleaning up lingering php-fpm processes..."

    # STEP 1: Force remove socket files FIRST (this is what worked manually)
    echo ""
    echo "Step 1: Force removing socket files..."
    local sock_dirs="/opt/cpanel/ea-php*/root/usr/var/run/php-fpm /var/run/php-fpm /run/php /tmp"
    local sock_pattern="*.sock"
    local sockets_removed=0

    if [ -n "$php_version" ]; then
        # Target specific PHP version sockets
        sock_pattern="*php${php_version}*.sock"
        echo "  Targeting PHP $php_version sockets: $sock_pattern"
    else
        echo "  Targeting all PHP-FPM sockets: $sock_pattern"
    fi

    for dir in $sock_dirs; do
        # Use glob expansion to handle wildcards in directory path
        for expanded_dir in $dir; do
            if [ -d "$expanded_dir" ]; then
                local found_socks
                found_socks=$(find "$expanded_dir" -name "$sock_pattern" -type s 2>/dev/null || true)
                if [ -n "$found_socks" ]; then
                    while IFS= read -r sock_file; do
                        [ -z "$sock_file" ] && continue
                        echo "  Force removing: $sock_file"
                        if rm -f "$sock_file" 2>/dev/null; then
                            echo "  âœ“ Removed $sock_file"
                            sockets_removed=$((sockets_removed + 1))
                            actions_taken=1
                        else
                            echo "  âœ— Failed to remove $sock_file"
                        fi
                    done <<< "$found_socks"
                fi
            fi
        done
    done

    if [ "$sockets_removed" -gt 0 ]; then
        echo "  âœ… Removed $sockets_removed socket file(s)"
    else
        echo "  â„¹ï¸  No socket files found to remove"
    fi

    # STEP 2: Use killall -9 (this is what worked manually)
    echo ""
    echo "Step 2: Using killall -9 to terminate php-fpm processes..."

    if command -v killall >/dev/null 2>&1; then
        local killall_targets=()

        if [ -n "$php_version" ]; then
            # Target specific version patterns
            # cPanel naming: ea-php74-php-fpm, php74-fpm, php-fpm (if it's the only version)
            killall_targets=(
                "ea-php${php_version}-php-fpm"
                "php${php_version}-fpm"
            )
            echo "  Targeting PHP $php_version processes"
        else
            # Kill all php-fpm processes (all versions)
            killall_targets=("php-fpm")
            echo "  Targeting all php-fpm processes"
        fi

        for target in "${killall_targets[@]}"; do
            echo "  Attempting: killall -9 $target"
            if killall -9 "$target" 2>/dev/null; then
                echo "  âœ“ Killed processes matching: $target"
                killed_count=$((killed_count + 1))
                actions_taken=1
            else
                # Not an error - process may not exist
                echo "  â„¹ï¸  No processes found matching: $target"
            fi
        done

        # Also try generic php-fpm if we have a version specified and nothing was killed yet
        if [ -n "$php_version" ] && [ "$killed_count" -eq 0 ]; then
            echo "  Attempting generic: killall -9 php-fpm"
            if killall -9 php-fpm 2>/dev/null; then
                echo "  âœ“ Killed generic php-fpm processes"
                killed_count=$((killed_count + 1))
                actions_taken=1
            fi
        fi
    else
        echo "  âš ï¸  killall command not available, using fallback method"
    fi

    # STEP 3: Use lsof for targeted cleanup of any remaining processes (belt and suspenders)
    if command -v lsof >/dev/null 2>&1; then
        echo ""
        echo "Step 3: Using lsof for targeted cleanup of remaining processes..."

        # Build search pattern based on php version if provided
        local sock_pattern="php-fpm.*\.sock"
        if [ -n "$php_version" ]; then
            sock_pattern="php${php_version}.*\.sock"
        fi

        # Find any remaining socket files that have open handles
        local socket_files
        socket_files=$(lsof 2>/dev/null | grep -E "$sock_pattern" | awk '{print $NF}' | sort -u || true)

        if [ -n "$socket_files" ]; then
            echo "  Found remaining socket file(s) with open handles:"
            echo "$socket_files" | sed 's/^/    /'
            echo ""

            # For each socket file, find PIDs holding it open and kill them
            while IFS= read -r sock_file; do
                [ -z "$sock_file" ] && continue

                local pids
                pids=$(lsof "$sock_file" 2>/dev/null | tail -n +2 | awk '{print $2}' | sort -u || true)

                if [ -n "$pids" ]; then
                    echo "  Socket: $sock_file"
                    for pid in $pids; do
                        local proc_name
                        proc_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")

                        echo "    Killing PID $pid ($proc_name)..."
                        if kill -9 "$pid" 2>/dev/null; then
                            echo "    âœ“ Killed PID $pid"
                            killed_count=$((killed_count + 1))
                            actions_taken=1
                        else
                            echo "    âœ— PID $pid already gone"
                        fi
                    done
                fi
            done <<< "$socket_files"
        else
            echo "  â„¹ï¸  No remaining socket files found via lsof"
        fi
    fi

    # STEP 4: Final cleanup - remove any remaining socket files
    echo ""
    echo "Step 4: Final socket cleanup..."
    local final_socks_removed=0

    for dir in $sock_dirs; do
        for expanded_dir in $dir; do
            if [ -d "$expanded_dir" ]; then
                local found_socks
                found_socks=$(find "$expanded_dir" -name "$sock_pattern" -type s 2>/dev/null || true)
                if [ -n "$found_socks" ]; then
                    while IFS= read -r sock_file; do
                        [ -z "$sock_file" ] && continue
                        echo "  Force removing: $sock_file"
                        rm -f "$sock_file" 2>/dev/null && final_socks_removed=$((final_socks_removed + 1)) || true
                    done <<< "$found_socks"
                fi
            fi
        done
    done

    if [ "$final_socks_removed" -gt 0 ]; then
        echo "  âœ… Removed $final_socks_removed additional socket file(s)"
        actions_taken=1
    else
        echo "  â„¹ï¸  No additional socket files to remove"
    fi

    # Summary
    echo ""
    if [ "$actions_taken" -eq 1 ]; then
        echo "âœ… Cleanup complete. Waiting 3 seconds for full process termination..."
        sleep 3
        return 0
    else
        echo "â„¹ï¸  No cleanup actions were necessary"
        return 1
    fi
}

# Function to perform the blacklist action (Manual Ban)
# UPDATED to accept an optional message
perform_blacklist() {
    ensure_setup
    local ip="$1"
    local message="$2"
    
    local timestamp_cmd
    timestamp_cmd=$(date "+%Y-%m-%d %H:%M:%S")
    local timestamp=${timestamp_cmd}
    
    local country=""

    echo "--- ğŸ”´ Blacklist Action: $ip ---"

    if ! validate_ip "$ip"; then
        echo "Error: Invalid IP address format: $ip"
        exit 1
    fi

    # FIX: Use braces around simple variable to prevent SC2015 warning
    if grep -q "^${ip}[[:space:]]*" "$CSF_ALLOW_FILE"; then
        echo "IP $ip is **WHITELISTED** in $CSF_ALLOW_FILE. Skipping blacklist action."
        exit 0
    fi

    if ipset test "$IP_SET_NAME" "$ip" &> /dev/null; then
        echo "IP $ip is already in ipset: $IP_SET_NAME. Skipping insertion."
        local end_time_cmd
        end_time_cmd=$(date +%s)
        local end_time=${end_time_cmd}
        report_ban_counts "Post-Blacklist Report" 0 "$end_time"
        exit 0
    fi
    
    # Use the same lookup method as the batch lookup for consistency
    local country_cmd
    country_cmd=$(geoiplookup "$ip" 2>/dev/null | sed -n -e 's/GeoIP Country Edition: //p' | gawk -F', ' '{print $2}' | sed 's/^[[:space:]]*//')
    country=${country_cmd}
    country=${country:-"Unknown_Country"}

    # Use the custom message or a default
    local ban_reason="Manual Blacklist: ${message:-"Manually blacklisted via --blacklist"}"
    
    local current_ban_count_cmd
    current_ban_count_cmd=$(wc -l < "$IP_TRACKING_FILE")
    local current_ban_count=${current_ban_count_cmd}
  
    if [ "$current_ban_count" -ge "$MAX_BANS" ]; then
        echo "WARNING: Ban limit ($MAX_BANS) reached. IP $ip will be added, but the oldest rotatable IP will be removed on the next cron run."
    fi

    ban_reason="$ban_reason ($country)"

    if ipset add "$IP_SET_NAME" "$ip" -exist; then
        echo "Added $ip to ipset: $IP_SET_NAME."
    else
        echo "ERROR: Failed to add $ip to ipset. Check ipset utility and permissions."
        exit 1
    fi

    # If conntrack-tools is available, delete any conntrack entries for this IP so
    # established sessions are terminated immediately.
    if command -v conntrack >/dev/null 2>&1; then
        conntrack -D -s "$ip" >/dev/null 2>&1 || true
    fi

    echo "$ip # [$timestamp] $ban_reason" | tee -a "$IP_TRACKING_FILE" > /dev/null
    echo "Added $ip to tracking file: $IP_TRACKING_FILE."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    report_ban_counts "Post-Blacklist Report" 1 "$end_time"
    exit 0
}

# Function to perform the whitelist action
# UPDATED to accept an optional message
perform_whitelist() {
    ensure_setup
    local ip="$1"
    local message="$2"
    local timestamp_cmd
    timestamp_cmd=$(date "+%Y-%m-%d %H:%M:%S")
    local timestamp=${timestamp_cmd}
    
    # Use the custom message or a default
    local reason="${message:-"Manual Whitelist"}"
    local comment="# Added via script at $timestamp. Reason: $reason"

    echo "--- ğŸŸ¢ Whitelist Action: $ip ---"

    # FIX: Use braces around simple variable to prevent SC2015 warning
    if ! grep -q "^${ip}[[:space:]]*" "$CSF_ALLOW_FILE"; then
        echo "$ip $comment" | tee -a "$CSF_ALLOW_FILE" > /dev/null
        echo "Added $ip to $CSF_ALLOW_FILE."
    else
        echo "$ip is already present in $CSF_ALLOW_FILE."
    fi

    if ipset test "$IP_SET_NAME" "$ip" &> /dev/null; then
        ipset del "$IP_SET_NAME" "$ip"
        echo "Removed $ip from ipset: $IP_SET_NAME."
    else
        echo "$ip was not found in ipset: $IP_SET_NAME (no action taken)."
    fi

    local line_number_cmd
    line_number_cmd=$(grep -n "^$ip " "$IP_TRACKING_FILE" 2>/dev/null | cut -d: -f1 | head -1)
    local line_number=${line_number_cmd}

    if [ -n "$line_number" ]; then
        sed -i "${line_number}d" "$IP_TRACKING_FILE"
        echo "Removed $ip from tracking file: $IP_TRACKING_FILE (Line: $line_number)."
    else
        echo "$ip was not found in tracking file (no action taken)."
    fi

    # Remove any per-IP iptables DROP fallback rule we may have inserted earlier
    # No per-IP iptables cleanup here â€” conntrack is preferred. If you want immediate
    # termination of established connections, install conntrack-tools (see --init message).

    echo "Reloading CSF to apply $CSF_ALLOW_FILE changes..."
    /usr/sbin/csf -r

    echo "Whitelist action complete for $ip."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    report_ban_counts "Post-Whitelist Report" 0 "$end_time"
    exit 0
}

# Function to initialize IPSET and CSF rules
perform_init() {
    local ip_set_line="ipset create $IP_SET_NAME hash:ip maxelem $MAX_BANS -exist"

    local iptables_path
    local path_cmd

    path_cmd=$(get_iptables_path)
    iptables_path=${path_cmd}
    
    if [ -z "$iptables_path" ]; then
        echo "ERROR: Cannot find a valid path for the iptables executable. Initialization cannot proceed."
        exit 1
    fi
    local iptables_rule_line="$iptables_path -A INPUT -m set --match-set $IP_SET_NAME src -j DROP"

    echo "--- ğŸ› ï¸ Initialization Action ---"

    echo "1. Creating IPSET table: $IP_SET_NAME with max size $MAX_BANS..."
    if ! ipset create "$IP_SET_NAME" hash:ip maxelem "$MAX_BANS" -exist; then
        echo "ERROR: Failed to create ipset '$IP_SET_NAME'. Check ipset utility and permissions."
        exit 1
    fi

    echo "2. Adding IPSET creation command to $CSF_POST_FILE..."
    if ! grep -q "$ip_set_line" "$CSF_POST_FILE"; then
        echo -e "\n# Rule added by $0 for high-volume IP banning\n$ip_set_line" | tee -a "$CSF_POST_FILE" > /dev/null
    fi

    echo "3. Adding portable iptables DROP rule ($iptables_path) for IPSET to $CSF_POST_FILE..."
    if ! grep -q "$iptables_rule_line" "$CSF_POST_FILE"; then
        echo "$iptables_rule_line" | tee -a "$CSF_POST_FILE" > /dev/null
    fi

    echo "4. Ensuring tracking file $IP_TRACKING_FILE exists..."
    touch "$IP_TRACKING_FILE" || { echo "ERROR: Cannot create tracking file $IP_TRACKING_FILE"; exit 1; }

    echo "5. Reloading CSF to apply new rules..."
    /usr/sbin/csf -r
    
    echo "Initialization complete. The system is ready for the high-volume ban script to run."
    # CONNTRACK CHECK: Recommend installing conntrack-tools if you want bans to immediately
    # terminate established connections. If conntrack is not present, bans still apply to
    # new connections but existing sessions may persist until closed/timeout.
    if ! command -v conntrack >/dev/null 2>&1; then
        echo "NOTE: 'conntrack' (conntrack-tools) is not installed on this host." 
        echo "If you want bans to immediately terminate existing TCP sessions, install conntrack-tools."
        echo "Example (RHEL/CentOS): sudo yum install -y conntrack-tools"
        echo "Example (Debian/Ubuntu): sudo apt-get install -y conntrack"
    else
        echo "conntrack-tools detected: the script can delete conntrack entries to immediately drop existing sessions when an IP is added."
    fi
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    echo "Initialization run time: $((end_time - START_TIME))s" 
    exit 0
}

# Function to completely flush the IPSET and clear the tracking file
perform_clear() {
    ensure_setup
    
    echo " "
    echo "====================================================================="
    echo "âš ï¸  DANGER: FULL IPSET CLEAR ACTION"
    echo "====================================================================="
    
    if [ -t 0 ]; then
        read -r -p "ARE YOU SURE you want to clear ALL $IP_SET_NAME bans? Type 'YES' to proceed: " response
        
        if [[ "$response" != "YES" ]]; then
            echo "Clear action aborted by user. No changes were made."
            exit 0
        fi
    else
        echo "ERROR: --clear flag used in a non-interactive environment (cron/script)."
        exit 1
    fi
    
    echo "Proceeding with full IPSET flush and tracking file clear..."
    
    if ipset flush "$IP_SET_NAME"; then
        echo "Successfully flushed all entries from ipset: $IP_SET_NAME."
    else
        echo "ERROR: Failed to flush ipset '$IP_SET_NAME'."
        exit 1
    fi
    
    if truncate -s 0 "$IP_TRACKING_FILE"; then
        echo "Successfully cleared all content from tracking file: $IP_TRACKING_FILE."
    else
        if true > "$IP_TRACKING_FILE"; then
            echo "Successfully cleared all content from tracking file: $IP_TRACKING_FILE (using redirection)."
        else
            echo "ERROR: Failed to clear tracking file '$IP_TRACKING_FILE'."
            exit 1
        fi
    fi

    echo "IPSET '$IP_SET_NAME' is now empty. All prior bans are removed."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    report_ban_counts "Post-Clear Report" 0 "$end_time"
    # No per-IP iptables cleanup here â€” conntrack is preferred. If you want immediate
    # termination of established connections, install conntrack-tools (see --init message).
    exit 0
}

# Function to install/configure ModSecurity integration
perform_install_modsecurity_triggers() {
    echo "====================================================================="
    echo "ğŸ”’ ModSecurity Integration Setup"
    echo "====================================================================="
    echo ""
    echo "This will generate ModSecurity rules that trigger IMMEDIATE IP bans"
    echo "on first malicious request, without waiting for the cron-based log scan."
    echo ""

    # Define the most critical patterns that should trigger instant bans
    local CRITICAL_PATTERNS=(
        "php://filter"
        "/etc/passwd"
        "union select"
        "base64_decode"
        "wso.php"
        "/+CSCOE+/logon.html"
        "alfacgiapi"
        "alfashell.php"
        "\.env"
        "/indo.php"
        "/as.php"
        "/0x0x.php"
        "/h.php"
        "/dex.php"
        "gel4y.php"
        "bu4.php"
    )

    # Detect cPanel/WHM vs standard Apache
    local MODSEC_RULE_FILE
    local IS_CPANEL=0
    local APACHE_USER="apache"

    if [ -d "/usr/local/cpanel" ] || [ -d "/usr/local/apache/conf" ]; then
        IS_CPANEL=1
        APACHE_USER="nobody"  # cPanel uses 'nobody' for Apache
        # cPanel/WHM: use includes directory that persists across Apache rebuilds
        MODSEC_RULE_FILE="/usr/local/apache/conf/includes/pre_virtualhost_global.conf"
    elif [ -d "/etc/httpd/conf.d" ]; then
        # RHEL/CentOS standard
        MODSEC_RULE_FILE="/etc/httpd/conf.d/modsecurity_instant_ban.conf"
    elif [ -d "/etc/apache2/conf.d" ]; then
        # Debian/Ubuntu
        MODSEC_RULE_FILE="/etc/apache2/conf.d/modsecurity_instant_ban.conf"
        APACHE_USER="www-data"
    else
        MODSEC_RULE_FILE="/etc/modsecurity_instant_ban.conf"
    fi

    local SCRIPT_PATH
    SCRIPT_PATH=$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")

    echo "Selected ${#CRITICAL_PATTERNS[@]} high-severity patterns for instant ban:"
    echo ""
    for pattern in "${CRITICAL_PATTERNS[@]}"; do
        echo "  - $pattern"
    done
    echo ""

    if [ $IS_CPANEL -eq 1 ]; then
        echo "ğŸ”§ Detected cPanel/WHM system"
        echo "Rule file location: $MODSEC_RULE_FILE"
        echo "  (This location persists across Apache rebuilds)"
        echo "Apache user: $APACHE_USER"
    else
        echo "Rule file location: $MODSEC_RULE_FILE"
        echo "Apache user: $APACHE_USER"
    fi
    echo "Ban script location: $SCRIPT_PATH"
    echo ""

    # Generate the ModSecurity rules
    local TEMP_RULE_FILE
    TEMP_RULE_FILE=$(mktemp)

    local INSTALL_DATE
    INSTALL_DATE=$(date '+%Y-%m-%d %H:%M:%S %Z')

    cat > "$TEMP_RULE_FILE" <<MODSEC_EOF
# ============================================================================
# ModSecurity Instant Ban Integration
# ============================================================================
# What:    Instant IP banning on first malicious request
# Script:  csf_ban_wp_login_attackers --install-mod-security-triggers
# Repo:    https://github.com/gserafini/useful-server-scripts
# When:    $INSTALL_DATE
# By:      ${SUDO_USER:-${USER:-root}}
#
# These rules trigger immediate IP banning on first malicious request
# instead of waiting for the cron-based log scanning (5-minute delay).
# ============================================================================

<IfModule mod_security2.c>
MODSEC_EOF

    # Build pattern match list for SecRule
    local PATTERN_LIST=""
    for pattern in "${CRITICAL_PATTERNS[@]}"; do
        if [ -n "$PATTERN_LIST" ]; then
            PATTERN_LIST="$PATTERN_LIST "
        fi
        PATTERN_LIST="$PATTERN_LIST$pattern"
    done

    # Add the ModSecurity rule
    cat >> "$TEMP_RULE_FILE" <<MODSEC_EOF

  # Rule to detect and ban malicious requests
  SecRule REQUEST_URI|ARGS "@pm $PATTERN_LIST" \\
      "id:999001,\\
      phase:2,\\
      t:none,t:lowercase,t:urlDecode,\\
      deny,\\
      status:403,\\
      log,\\
      msg:'Critical malicious pattern detected - triggering instant ban',\\
      logdata:'Matched pattern in: %{MATCHED_VAR_NAME}=%{MATCHED_VAR}',\\
      tag:'attack/injection',\\
      severity:'CRITICAL',\\
      setenv:MALICIOUS_IP=%{REMOTE_ADDR},\\
      exec:'$SCRIPT_PATH'"

</IfModule>
MODSEC_EOF

    # Check if ModSecurity directory exists before showing the rule
    if [ ! -d "/etc/httpd/conf.d" ] && [ ! -d "/etc/apache2/mods-enabled" ] && [ ! -d "/usr/local/apache/conf" ]; then
        echo "====================================================================="
        echo "âš ï¸  WARNING: Could not detect Apache/ModSecurity installation directory."
        echo "====================================================================="
        echo ""
        echo "Common locations:"
        echo "  - /usr/local/apache/conf/ (cPanel/WHM)"
        echo "  - /etc/httpd/conf.d/ (RHEL/CentOS)"
        echo "  - /etc/apache2/mods-enabled/ (Debian/Ubuntu)"
        echo ""
        echo "Generated rule content has been saved to: $TEMP_RULE_FILE"
        echo ""
        echo "====================================================================="
        echo "RULE CONTENT:"
        echo "====================================================================="
        cat "$TEMP_RULE_FILE"
        echo ""
        echo "====================================================================="
        echo ""
        echo "Please manually place this file in your ModSecurity configuration directory."
        echo ""
        return 1
    fi

    # Display the complete rule that will be installed
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "                   ğŸ“‹ MODSECURITY RULE PREVIEW"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "The following rule will be written to:"
    echo "  ğŸ‘‰ $MODSEC_RULE_FILE"
    echo ""
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    cat "$TEMP_RULE_FILE"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo ""
    echo "What this rule does:"
    echo "  â€¢ Matches ${#CRITICAL_PATTERNS[@]} critical malicious patterns"
    echo "  â€¢ Denies request with 403 Forbidden"
    echo "  â€¢ Sets MALICIOUS_IP environment variable"
    echo "  â€¢ Executes: $SCRIPT_PATH --blacklist \$IP"
    echo "  â€¢ Triggers INSTANT ban (no cron delay)"
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # Offer to install
    if [ -t 0 ]; then
        read -r -p "Write this rule to $MODSEC_RULE_FILE? (yes/no): " response

        if [[ "$response" =~ ^[Yy][Ee][Ss]$ ]]; then
            echo ""

            # Check if the config file exists and if our rule is already there
            local RULE_MARKER="# ModSecurity Instant Ban Integration"
            local RULE_EXISTS=0
            local FILE_EXISTS=0

            if [ -f "$MODSEC_RULE_FILE" ]; then
                FILE_EXISTS=1
                if grep -q "$RULE_MARKER" "$MODSEC_RULE_FILE"; then
                    RULE_EXISTS=1
                fi
            fi

            if [ $RULE_EXISTS -eq 1 ]; then
                echo "âš ï¸  Existing rule detected in $MODSEC_RULE_FILE"
                echo "Updating rule in place..."
                echo ""

                # Create backup with unique timestamp
                local BACKUP_FILE="${MODSEC_RULE_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
                cp "$MODSEC_RULE_FILE" "$BACKUP_FILE"
                echo "Backup created: $BACKUP_FILE"

                # Remove ALL old rule blocks (handles multiple duplicates)
                # More robust pattern matching to catch all variations
                awk '
                    BEGIN { in_block=0; skip_blank=0 }

                    # Start of our block - multiple possible patterns
                    /^# =+$/ && /=+$/ {
                        getline next_line
                        if (next_line ~ /ModSecurity Instant Ban Integration/) {
                            in_block=1
                            next
                        } else {
                            print $0
                            print next_line
                            next
                        }
                    }

                    # Also catch by the comment header
                    /# ModSecurity Instant Ban Integration/ {
                        in_block=1
                        next
                    }

                    # Inside block - skip everything
                    in_block {
                        # Look for closing tag
                        if (/<\/IfModule>/) {
                            in_block=0
                            skip_blank=1
                            next
                        }
                        next
                    }

                    # Skip one blank line after block
                    skip_blank && /^[[:space:]]*$/ {
                        skip_blank=0
                        next
                    }
                    skip_blank {
                        skip_blank=0
                    }

                    # Print everything else
                    !in_block { print }
                ' "$MODSEC_RULE_FILE" > "${MODSEC_RULE_FILE}.tmp"

                # Verify the temp file was created and has content
                if [ ! -s "${MODSEC_RULE_FILE}.tmp" ]; then
                    echo "âŒ ERROR: Rule removal resulted in empty file!"
                    echo "Original file preserved. Please check manually."
                    rm -f "${MODSEC_RULE_FILE}.tmp"
                    return 1
                fi

                # Append new rule to the temp file
                echo "" >> "${MODSEC_RULE_FILE}.tmp"
                cat "$TEMP_RULE_FILE" >> "${MODSEC_RULE_FILE}.tmp"

                # Replace original with updated version
                mv "${MODSEC_RULE_FILE}.tmp" "$MODSEC_RULE_FILE"
                chmod 644 "$MODSEC_RULE_FILE"

                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âœ…  SUCCESS: ModSecurity Rule Updated"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo ""
                echo "Rule updated in: $MODSEC_RULE_FILE"
                echo "Previous version backed up"
                echo ""

            elif [ $FILE_EXISTS -eq 1 ]; then
                echo "Appending rule to existing $MODSEC_RULE_FILE..."
                echo ""

                # Create backup with unique timestamp
                local BACKUP_FILE="${MODSEC_RULE_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
                cp "$MODSEC_RULE_FILE" "$BACKUP_FILE"
                echo "Backup created: $BACKUP_FILE"

                # Append new rule
                echo "" >> "$MODSEC_RULE_FILE"
                cat "$TEMP_RULE_FILE" >> "$MODSEC_RULE_FILE"
                chmod 644 "$MODSEC_RULE_FILE"

                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âœ…  SUCCESS: ModSecurity Rule Appended"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo ""
                echo "Rule appended to: $MODSEC_RULE_FILE"
                echo "Previous version backed up"
                echo ""

            else
                echo "Creating new $MODSEC_RULE_FILE..."
                echo ""

                # Create new file
                cat "$TEMP_RULE_FILE" > "$MODSEC_RULE_FILE"
                chmod 644 "$MODSEC_RULE_FILE"

                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo "âœ…  SUCCESS: ModSecurity Rule Created"
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo ""
                echo "Rule file created: $MODSEC_RULE_FILE"
                echo ""
            fi

                # Automatically configure sudoers if running as root
                local SUDOERS_CONFIGURED=0
                if [ "$EUID" -eq 0 ]; then
                    echo "Configuring sudo access for Apache user ($APACHE_USER)..."
                    local SUDOERS_FILE="/etc/sudoers.d/modsecurity_ban"
                    local SUDOERS_RULE="$APACHE_USER ALL=(ALL) NOPASSWD: $SCRIPT_PATH --blacklist *"

                    if echo "$SUDOERS_RULE" > "$SUDOERS_FILE" 2>/dev/null && chmod 440 "$SUDOERS_FILE" 2>/dev/null; then
                        echo "âœ… Sudoers configured: $SUDOERS_FILE"
                        SUDOERS_CONFIGURED=1
                    else
                        echo "âš ï¸  Could not write sudoers file (will show manual instructions)"
                        SUDOERS_CONFIGURED=0
                    fi
                    echo ""
                fi

                # Determine if we need sudo prefix for remaining commands
                local SUDO_PREFIX=""
                if [ "$EUID" -ne 0 ]; then
                    SUDO_PREFIX="sudo "
                fi

                if [ $IS_CPANEL -eq 1 ]; then
                    echo "ğŸ“‹ cPanel/WHM - Configuration Summary:"
                    echo ""
                    if [ $SUDOERS_CONFIGURED -eq 1 ]; then
                        echo "  âœ… Sudoers configured"
                        echo "  âœ… ModSecurity rules installed"
                        echo "  âœ… Apache/PHP-FPM restarted"
                    else
                        echo "  âš ï¸  Sudoers NOT configured (manual step required)"
                        echo "  âœ… ModSecurity rules installed"
                        echo "  âœ… Apache/PHP-FPM restarted"
                    fi
                    echo ""
                    if [ $SUDOERS_CONFIGURED -eq 0 ]; then
                        echo "âš ï¸  Manual step required:"
                        echo "   Configure sudo access for Apache user:"
                        echo "   echo '$APACHE_USER ALL=(ALL) NOPASSWD: $SCRIPT_PATH --blacklist *' | ${SUDO_PREFIX}tee /etc/sudoers.d/modsecurity_ban"
                        echo "   ${SUDO_PREFIX}chmod 440 /etc/sudoers.d/modsecurity_ban"
                        echo ""
                    fi
                    echo "Additional checks:"
                    echo "  â€¢ Verify ModSecurity is enabled in WHM:"
                    echo "    WHM > Security Center > ModSecurityâ„¢ Configuration"
                    echo ""
                    echo "  â€¢ Monitor for instant bans:"
                    echo "    tail -f $IP_TRACKING_FILE"
                    echo ""
                    echo "  â€¢ Check Apache error log if rules don't trigger:"
                    echo "    tail -f /usr/local/apache/logs/error_log | grep -i modsec"
                    echo ""
                    echo "â„¹ï¸  Note: The rule file location persists across Apache rebuilds via EasyApache."
                else
                    echo "Configuration Summary:"
                    echo ""
                    if [ $SUDOERS_CONFIGURED -eq 1 ]; then
                        echo "  âœ… Sudoers configured"
                        echo "  âœ… ModSecurity rules installed"
                        echo "  âœ… Apache/PHP-FPM restarted"
                    else
                        echo "  âš ï¸  Sudoers NOT configured (manual step required)"
                        echo "  âœ… ModSecurity rules installed"
                        echo "  âœ… Apache/PHP-FPM restarted"
                    fi
                    echo ""
                    if [ $SUDOERS_CONFIGURED -eq 0 ]; then
                        echo "âš ï¸  Manual step required:"
                        echo "   Configure sudo access:"
                        echo "   echo '$APACHE_USER ALL=(ALL) NOPASSWD: $SCRIPT_PATH --blacklist *' | ${SUDO_PREFIX}tee /etc/sudoers.d/modsecurity_ban"
                        echo "   ${SUDO_PREFIX}chmod 440 /etc/sudoers.d/modsecurity_ban"
                        echo ""
                    fi
                    echo "Additional checks:"
                    echo "  â€¢ Test Apache configuration:"
                    echo "    apachectl configtest"
                    echo ""
                    echo "  â€¢ Monitor for bans:"
                    echo "    tail -f $IP_TRACKING_FILE"
                fi
                echo ""
                echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

                # Restart Apache and PHP-FPM to load the new ModSecurity rules
                echo ""
                echo "Restarting Apache and PHP-FPM to load ModSecurity rules..."
                echo ""

                # Restart services: use cPanel legacy scripts on CentOS <7, systemctl on CentOS >=7
                centos_major=""
                if [ -f /etc/centos-release ]; then
                    centos_major=$(sed -n 's/.*release \([0-9]\+\).*/\1/p' /etc/centos-release)
                elif [ -f /etc/redhat-release ]; then
                    centos_major=$(sed -n 's/.*release \([0-9]\+\).*/\1/p' /etc/redhat-release)
                fi

                # fallback to lsb_release if parsing failed
                if ! [[ "$centos_major" =~ ^[0-9]+$ ]] && command -v lsb_release >/dev/null 2>&1; then
                    centos_major=$(lsb_release -sr | cut -d. -f1)
                fi

                if [[ "$centos_major" =~ ^[0-9]+$ ]] && [ "$centos_major" -lt 7 ]; then
                    echo "Detected CentOS $centos_major (<7): using cPanel restart scripts..."
		    echo "/scripts/restartsrv_httpd --restart --hard"
		    echo "/usr/local/cpanel/scripts/restartsrv_apache_php_fpm --restart --hard"
                    /scripts/restartsrv_httpd --restart --hard
                    
                    # Attempt php-fpm restart with retry logic on failure
                    # Capture output to check for error patterns since cPanel scripts may not return proper exit codes
                    local phpfpm_output
                    phpfpm_output=$(/usr/local/cpanel/scripts/restartsrv_apache_php_fpm --restart --hard 2>&1)
                    local phpfpm_exitcode=$?
                    echo "$phpfpm_output"
                    
                    # Check if restart failed (either by exit code or error patterns in output)
                    if [ "$phpfpm_exitcode" -ne 0 ] || echo "$phpfpm_output" | grep -qE '\[FAILED\]|FPM initialization failed|already listen on'; then
                        echo "âš ï¸  PHP-FPM restart failed (exit code: $phpfpm_exitcode). Attempting to kill lingering processes..."
                        kill_lingering_phpfpm_processes
                        echo "ğŸ”„ Retrying PHP-FPM restart..."
                        /usr/local/cpanel/scripts/restartsrv_apache_php_fpm --restart --hard
                    fi
                else
                    echo "Detected CentOS ${centos_major:-unknown} (>=7 or undetermined): using systemctl/service fallback..."

                    # Restart Apache/httpd first
                    if /bin/systemctl restart httpd.service 2>/dev/null; then
			echo "/bin/systemctl restart httpd.service"
                        echo "âœ“ httpd restarted via systemctl"
                    else
                        echo "systemctl unavailable or failed; trying service httpd restart..."
			echo "service httpd restart"
                        service httpd restart 2>/dev/null && echo "âœ“ httpd restarted via service" || echo "âœ— Failed to restart httpd"
                    fi

                    # Discover php-fpm services dynamically instead of hard-coding
                    restarted_any_phpfpm=0
                    systemctl_cmd="$(command -v systemctl 2>/dev/null || true)"

                    if [ -n "$systemctl_cmd" ]; then
                        # List unit names and match typical php-fpm patterns (ea-php*, php*-fpm, php-fpm)
                        php_units=$($systemctl_cmd list-units --all --type=service --no-legend --no-pager 2>/dev/null | awk '{print $1}' | grep -E -i '(^ea-php[0-9]+-php-fpm\.service$|php([0-9]+)?-?fpm(\.service)?$)' || true)
                        # If none found, also check installed unit-files (covers disabled units)
                        if [ -z "$php_units" ]; then
                            php_units=$($systemctl_cmd list-unit-files --type=service --no-legend --no-pager 2>/dev/null | awk '{print $1}' | grep -E -i '(^ea-php[0-9]+-php-fpm\.service$|php([0-9]+)?-?fpm(\.service)?$)' || true)
                        fi

                        if [ -n "$php_units" ]; then
                            # Deduplicate and restart each using process substitution to avoid subshell
                            echo "Found php-fpm service units:"
                            while read -r svc; do
                                if [ -z "$svc" ]; then continue; fi
                                
                                # Extract PHP version from service name for targeted cleanup (e.g., ea-php74-php-fpm.service -> 74)
                                local php_ver=""
                                if [[ "$svc" =~ php([0-9]+) ]]; then
                                    php_ver="${BASH_REMATCH[1]}"
                                fi
                                
                                echo "$systemctl_cmd restart \"$svc\""
                                if $systemctl_cmd restart "$svc" 2>&1; then
                                    echo "âœ“ Restarted $svc via systemctl"
                                    restarted_any_phpfpm=1
                                else
                                    echo "âœ— Failed to restart $svc via systemctl"
                                    echo "âš ï¸  Attempting to kill lingering processes for $svc..."
                                    kill_lingering_phpfpm_processes "$php_ver"
                                    echo "ğŸ”„ Retrying restart of $svc..."
                                    if $systemctl_cmd restart "$svc" 2>&1; then
                                        echo "âœ“ Successfully restarted $svc after cleanup"
                                        restarted_any_phpfpm=1
                                    else
                                        echo "âœ— Failed to restart $svc even after cleanup"
                                    fi
                                fi
                            done < <(echo "$php_units" | sort -u)
                        fi
                    fi

                    # Fallback for non-systemd systems or if no units were discovered/restarted
                    if [ "$restarted_any_phpfpm" -eq 0 ]; then
                        echo "No php-fpm systemd units restarted (none discovered or systemctl unavailable). Trying service/init.d fallbacks..."

                        # Try common vendor names first (ea-php* and php-fpm)
                        for svc in ea-php82-php-fpm ea-php81-php-fpm ea-php74-php-fpm php-fpm; do
                            # Extract PHP version from service name for targeted cleanup
                            local php_ver=""
                            if [[ "$svc" =~ php([0-9]+) ]]; then
                                php_ver="${BASH_REMATCH[1]}"
                            fi
                            
                            local restart_success=0
                            
                            if command -v /bin/systemctl >/dev/null 2>&1; then
                                echo "/bin/systemctl restart \"${svc}.service\""
                                if /bin/systemctl restart "${svc}.service" 2>&1; then
                                    echo "âœ“ Restarted ${svc}.service via systemctl"
                                    restarted_any_phpfpm=1
                                    restart_success=1
                                fi
                            fi

                            # Try service wrapper if systemctl didn't work
                            if [ "$restart_success" -eq 0 ]; then
                                echo "service \"$svc\" restart"
                                if service "$svc" restart 2>&1; then
                                    echo "âœ“ Restarted $svc via service"
                                    restarted_any_phpfpm=1
                                    restart_success=1
                                fi
                            fi

                            # Try direct init script if present and previous attempts failed
                            if [ "$restart_success" -eq 0 ] && [ -x "/etc/init.d/$svc" ]; then
                                echo "/etc/init.d/\"$svc\" restart"
                                if /etc/init.d/"$svc" restart 2>&1; then
                                    echo "âœ“ Restarted $svc via /etc/init.d/$svc"
                                    restarted_any_phpfpm=1
                                    restart_success=1
                                fi
                            fi
                            
                            # If all attempts failed, try cleanup and retry
                            if [ "$restart_success" -eq 0 ]; then
                                # Check if the service actually exists before trying cleanup
                                if systemctl list-unit-files "${svc}.service" 2>/dev/null | grep -q "${svc}.service" || \
                                   [ -x "/etc/init.d/$svc" ] || \
                                   service "$svc" status >/dev/null 2>&1; then
                                    
                                    echo "âš ï¸  All restart attempts failed for $svc. Attempting to kill lingering processes..."
                                    kill_lingering_phpfpm_processes "$php_ver"
                                    echo "ğŸ”„ Retrying restart of $svc..."
                                    
                                    # Retry with same priority order
                                    if command -v /bin/systemctl >/dev/null 2>&1 && /bin/systemctl restart "${svc}.service" 2>&1; then
                                        echo "âœ“ Successfully restarted ${svc}.service after cleanup"
                                        restarted_any_phpfpm=1
                                    elif service "$svc" restart 2>&1; then
                                        echo "âœ“ Successfully restarted $svc via service after cleanup"
                                        restarted_any_phpfpm=1
                                    elif [ -x "/etc/init.d/$svc" ] && /etc/init.d/"$svc" restart 2>&1; then
                                        echo "âœ“ Successfully restarted $svc via init.d after cleanup"
                                        restarted_any_phpfpm=1
                                    else
                                        echo "âœ— Failed to restart $svc even after cleanup"
                                    fi
                                fi
                            fi
                        done

                        # As a last resort, scan /etc/init.d for any php*-fpm scripts and attempt restart
                        if [ "$restarted_any_phpfpm" -eq 0 ]; then
                            for script in /etc/init.d/*php*fpm* /etc/init.d/*php*; do
                                [ -e "$script" ] || continue
                                base=$(basename "$script")
                                
                                # Extract PHP version from script name
                                local php_ver=""
                                if [[ "$base" =~ php([0-9]+) ]]; then
                                    php_ver="${BASH_REMATCH[1]}"
                                fi
                                
                                local restart_success=0
                                echo "service \"$base\" restart"
                                if service "$base" restart 2>&1; then
                                    echo "âœ“ Restarted $base via service (from /etc/init.d scan)"
                                    restarted_any_phpfpm=1
                                    restart_success=1
                                elif [ -x "$script" ]; then
                                    echo "\"$script\" restart"
                                    if "$script" restart 2>&1; then
                                        echo "âœ“ Restarted $base via direct init.d script"
                                        restarted_any_phpfpm=1
                                        restart_success=1
                                    fi
                                fi
                                
                                # If restart failed, try cleanup and retry
                                if [ "$restart_success" -eq 0 ]; then
                                    echo "âš ï¸  Restart failed for $base. Attempting to kill lingering processes..."
                                    kill_lingering_phpfpm_processes "$php_ver"
                                    echo "ğŸ”„ Retrying restart of $base..."
                                    
                                    if service "$base" restart 2>&1; then
                                        echo "âœ“ Successfully restarted $base via service after cleanup"
                                        restarted_any_phpfpm=1
                                    elif [ -x "$script" ] && "$script" restart 2>&1; then
                                        echo "âœ“ Successfully restarted $base via init.d after cleanup"
                                        restarted_any_phpfpm=1
                                    else
                                        echo "âœ— Failed to restart $base even after cleanup"
                                    fi
                                fi
                            done
                        fi
                    fi

                    if [ "$restarted_any_phpfpm" -eq 0 ]; then
                        echo "âš ï¸  Warning: No php-fpm services were restarted. Please verify php-fpm service names on this host."
                    fi
                fi

                echo ""
                echo "Validating Apache configuration..."

                # Test Apache configuration syntax
                local CONFIG_TEST_RESULT=0
                if command -v apachectl >/dev/null 2>&1; then
                    if ! apachectl configtest 2>&1 | grep -q "Syntax OK"; then
                        CONFIG_TEST_RESULT=1
                    fi
                elif command -v /usr/local/apache/bin/httpd >/dev/null 2>&1; then
                    if ! /usr/local/apache/bin/httpd -t 2>&1 | grep -q "Syntax OK"; then
                        CONFIG_TEST_RESULT=1
                    fi
                fi

                # Check if Apache is actually running after restart
                local APACHE_RUNNING=0
                if [[ "$centos_major" =~ ^[0-9]+$ ]] && [ "$centos_major" -lt 7 ]; then
                    # cPanel old systems
                    if /scripts/restartsrv_httpd --status 2>/dev/null | grep -q "running"; then
                        APACHE_RUNNING=1
                    fi
                else
                    # systemctl systems
                    if systemctl is-active httpd.service >/dev/null 2>&1; then
                        APACHE_RUNNING=1
                    elif systemctl is-active apache2.service >/dev/null 2>&1; then
                        APACHE_RUNNING=1
                    elif service httpd status 2>/dev/null | grep -q "running"; then
                        APACHE_RUNNING=1
                    elif service apache2 status 2>/dev/null | grep -q "running"; then
                        APACHE_RUNNING=1
                    fi
                fi

                # Rollback if Apache failed
                if [ $CONFIG_TEST_RESULT -ne 0 ] || [ $APACHE_RUNNING -eq 0 ]; then
                    echo ""
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo "âŒ  ERROR: Apache configuration test failed or Apache not running!"
                    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                    echo "ğŸ”„ Rolling back to previous configuration..."

                    # Restore backup
                    if [ -f "$BACKUP_FILE" ]; then
                        cp "$BACKUP_FILE" "$MODSEC_RULE_FILE"
                        echo "âœ“ Previous configuration restored from: $BACKUP_FILE"

                        # Try to restart Apache with old config
                        echo ""
                        echo "Attempting to restart Apache with previous configuration..."
                        if [[ "$centos_major" =~ ^[0-9]+$ ]] && [ "$centos_major" -lt 7 ]; then
                            /scripts/restartsrv_httpd --restart --hard 2>&1
                        else
                            systemctl restart httpd.service 2>&1 || systemctl restart apache2.service 2>&1 || service httpd restart 2>&1
                        fi

                        echo ""
                        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                        echo "ğŸ” DEBUG INFORMATION:"
                        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                        echo ""
                        echo "The ModSecurity rule may have syntax errors. Check Apache error log:"
                        if [ -f /usr/local/apache/logs/error_log ]; then
                            echo ""
                            echo "Last 20 lines of Apache error log:"
                            tail -20 /usr/local/apache/logs/error_log 2>/dev/null || echo "(Could not read error log)"
                        elif [ -f /var/log/apache2/error.log ]; then
                            echo ""
                            echo "Last 20 lines of Apache error log:"
                            tail -20 /var/log/apache2/error.log 2>/dev/null || echo "(Could not read error log)"
                        elif [ -f /var/log/httpd/error_log ]; then
                            echo ""
                            echo "Last 20 lines of Apache error log:"
                            tail -20 /var/log/httpd/error_log 2>/dev/null || echo "(Could not read error log)"
                        fi
                        echo ""
                        echo "Generated rule (may contain errors):"
                        echo "  $TEMP_RULE_FILE"
                        echo ""
                        echo "Backup configuration:"
                        echo "  $BACKUP_FILE"
                        echo ""
                        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    else
                        echo "âŒ ERROR: Backup file not found! Cannot rollback."
                        echo "   Previous config should still be at: ${MODSEC_RULE_FILE}.backup.*"
                    fi

                    exit 1
                else
                    echo "âœ“ Apache configuration valid and service is running"
                    echo ""
                    echo "âœ… ModSecurity rules are now active!"
                    echo ""
                fi
        else
            echo ""
            local SUDO_PREFIX=""
            if [ "$EUID" -ne 0 ]; then
                SUDO_PREFIX="sudo "
            fi
            echo "Installation cancelled by user."
            echo ""
            echo "Rule content has been saved to: $TEMP_RULE_FILE"
            echo "To install manually later, run:"
            echo "  ${SUDO_PREFIX}cp $TEMP_RULE_FILE $MODSEC_RULE_FILE"
            echo "  ${SUDO_PREFIX}chmod 644 $MODSEC_RULE_FILE"
            echo ""
        fi
    else
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        local SUDO_PREFIX=""
        if [ "$EUID" -ne 0 ]; then
            SUDO_PREFIX="sudo "
        fi
        echo "Non-interactive mode detected."
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Rule content has been saved to: $TEMP_RULE_FILE"
        echo ""
        echo "To install, run:"
        echo "  ${SUDO_PREFIX}cp $TEMP_RULE_FILE $MODSEC_RULE_FILE"
        echo "  ${SUDO_PREFIX}chmod 644 $MODSEC_RULE_FILE"
        echo ""
    fi

    # Don't delete temp file - leave it for manual installation if needed
    echo "Note: Temporary rule file preserved at: $TEMP_RULE_FILE"
    exit 0
}


# --- COMMAND LINE ARGUMENT PARSING ---
if ! TEMP_ARGS_CMD=$(getopt -o '' --long init,whitelist:,blacklist:,block:,unblock:,logs:,clear,install-mod-security-triggers,abuse:,abuse-report:,abuse-min:,abuse-days:,abuse-since:,abuse-until:,abuse-email,raw-grep:,raw-search:,help -n 'csf_ban_wp_login_attackers' -- "$@"); then
    echo "Terminating..." >&2
    exit 1
fi
TEMP_ARGS=${TEMP_ARGS_CMD}
eval set -- "$TEMP_ARGS"

while true; do
  case "$1" in
    --init )
      perform_init
      ;;
    --install-mod-security-triggers )
      perform_install_modsecurity_triggers
      ;;
        --help )
            echo "Usage: $0 [options]"
            echo "Options:"
            echo "  --init                    Initialize ipset and CSF hooks"
            echo "  --install-mod-security-triggers  Generate and install ModSecurity rules for instant banning"
            echo "  --whitelist <IP> [MSG]    Add IP to CSF allow list"
            echo "  --blacklist|--block <IP> [MSG]  Add IP to ipset and tracking (manual ban)"
            echo "  --logs \"<path1> <path2>\"    Override default log paths to scan"
            echo "  --clear                   Flush ipset and clear tracking file (interactive)"
            echo "  --abuse, --abuse-report <IP> [MIN_HITS]   Generate an abuse evidence report for <IP> (read-only)"
            echo "  --abuse-min <N>           Default minimum matched hits for abuse-report when MIN_HITS omitted"
            echo "  --abuse-days <N>          Best-effort: restrict search to last N days (depends on log timestamps)"
            echo "  --abuse-since <STRING>    Simple substring filter for 'since' date token"
            echo "  --abuse-until <STRING>    Simple substring filter for 'until' date token"
            echo "  --abuse-email             Attempt minimal whois lookup and print a draft abuse email"
            echo "  --raw-grep <STRING>       Run a raw grep for <STRING> across configured log files and print results (read-only)"
            echo "  --raw-search <STRING>     Alias for --raw-grep"
            exit 0
            ;;
    --whitelist | --unblock )
      # $1 is --whitelist or --unblock
      IP_TO_WHITELIST="$2"
      MESSAGE_TO_USE=""

      if [ -z "$IP_TO_WHITELIST" ] || ! validate_ip "$IP_TO_WHITELIST"; then
          echo "Error: $1 requires a valid IP address argument."
          exit 1
      fi

      # Explicitly check for an optional message argument.
      # getopt inserts -- as separator, so message might be in $3 or $4
      if [ "$#" -ge 4 ] && [ "$3" = "--" ] && [ -n "$4" ]; then
          # Message is in $4 (after getopt's -- separator)
          MESSAGE_TO_USE="$4"
          shift 4 # Consume Flag, IP, --, and Message
      elif [ "$#" -ge 3 ] && [ "$3" != "--" ] && ! [[ "$3" =~ ^--.* ]]; then
          # Message is in $3 (no -- separator)
          MESSAGE_TO_USE="$3"
          shift 3 # Consume Flag, IP, and Message
      else
          shift 2 # Consume only Flag and IP (2 arguments)
      fi

      perform_whitelist "$IP_TO_WHITELIST" "$MESSAGE_TO_USE"
      ;;
    --blacklist | --block )
      # $1 is --blacklist or --block
      IP_TO_BLACKLIST="$2"
      MESSAGE_TO_USE=""

      if [ -z "$IP_TO_BLACKLIST" ] || ! validate_ip "$IP_TO_BLACKLIST"; then
          echo "Error: $1 requires a valid IP address argument."
          exit 1
      fi

      # Explicitly check for an optional message argument.
      # getopt inserts -- as separator, so message might be in $3 or $4
      if [ "$#" -ge 4 ] && [ "$3" = "--" ] && [ -n "$4" ]; then
          # Message is in $4 (after getopt's -- separator)
          MESSAGE_TO_USE="$4"
          shift 4 # Consume Flag, IP, --, and Message
      elif [ "$#" -ge 3 ] && [ "$3" != "--" ] && ! [[ "$3" =~ ^--.* ]]; then
          # Message is in $3 (no -- separator)
          MESSAGE_TO_USE="$3"
          shift 3 # Consume Flag, IP, and Message
      else
          shift 2 # Consume only Flag and IP (2 arguments)
      fi

      perform_blacklist "$IP_TO_BLACKLIST" "$MESSAGE_TO_USE"
      
      ;;
        --abuse-min )
            ABUSE_MIN="$2"
            shift 2
            ;;
        --abuse-days )
            ABUSE_DAYS="$2"
            shift 2
            ;;
        --abuse-since )
            ABUSE_SINCE="$2"
            shift 2
            ;;
        --abuse-until )
            ABUSE_UNTIL="$2"
            shift 2
            ;;
        --abuse-email )
            ABUSE_EMAIL=1
            shift
            ;;
        --abuse-report | --abuse )
      # $1 is --abuse-report or --abuse
      IP_TO_REPORT="$2"
            MIN_HITS_TO_USE=""

            if [ -z "$IP_TO_REPORT" ] || ! validate_ip "$IP_TO_REPORT"; then
                    echo "Error: $1 requires a valid IP address argument."
                    exit 1
            fi

            # Optional MIN_HITS argument handling (e.g., --abuse-report 1.2.3.4 50)
            if [ "$#" -ge 3 ] && [ "$3" != "--" ] && ! [[ "$3" =~ ^--.* ]]; then
                    MIN_HITS_TO_USE="$3"
                    shift 3
            else
                    shift 2
            fi

            # Prefer explicitly-passed MIN_HITS, otherwise use ABUSE_MIN if set
            if [ -z "$MIN_HITS_TO_USE" ] && [ -n "${ABUSE_MIN:-}" ]; then
                    MIN_HITS_TO_USE="${ABUSE_MIN}"
            fi

                            # Record requested abuse report parameters; actual call happens after functions are defined
                            ABUSE_RUN=1
                            ABUSE_IP="$IP_TO_REPORT"
                            ABUSE_MIN_HITS="$MIN_HITS_TO_USE"
                            shift 0
                            ;;
                    --raw-grep | --raw-search )
                      RAW_PATTERN="$2"
                      if [ -z "$RAW_PATTERN" ]; then
                          echo "Error: $1 requires a search string argument."
                          exit 1
                      fi
                      # Record requested raw search parameters; actual execution happens after functions are defined
                      RAW_RUN=1
                      RAW_PATTERN_ESCAPED="$RAW_PATTERN"
                      shift 2
                      ;;
    --logs )
      LOG_PATHS="$2"
      shift 2
      ;;
    --clear )
      perform_clear
      ;;
    -- )
      shift
      break
      ;;
    * )
      break
      ;;
  esac
done

if [ -z "$LOG_PATHS" ]; then
    LOG_PATHS="$DEFAULT_LOG_PATHS"
fi
# --- END ARGUMENT HANDLING ---

## ABUSE_RUN handling moved to after function definitions to ensure assemble_abuse_report is defined

# 0. ENSURE SETUP IS COMPLETE FOR MAIN LOGIC
ensure_setup

# --- KEYWORDS CONFIGURATION ---
declare -A keywords
keywords=(
  # --- RCE / LFI / SQL Injection Payload Indicators (New) ---
  ["1 php://filter"]="attempted Local File Inclusion (LFI) using php://filter wrapper"
  ["1 /etc/passwd"]="attempted file traversal/read of /etc/passwd"
  ["1 etc/passwd"]="attempted LFI payload without leading slash"
  ["1 /proc/self/cmdline"]="attempted read of system process info"
  ["1 union select"]="attempted SQL injection with UNION SELECT clause"
  ["1 base64_decode"]="attempted RCE using base64 encoded payload"
  ["5 wso.php"]="attempted access to a WSO or similar PHP web shell"

  # --- ModSecurity Violations (High Frequency) ---
  ["5 AH01797"]="error_log ModSecurity AH01797: client denied by server configuration"
  ["5 AH10244"]="error_log ModSecurity AH10244: invalid URI path"
  ["5 AH01071"]="error_log ModSecurity AH01071: Got error Primary script unknown - requesting missing php file"
  ["1 1234123440"]="error_log ModSecurity 1234123440: Access denied with code 406 - URL Encoding Abuse Attack Attempt"
  ["1 1234123438"]="error_log ModSecurity 1234123438: Access denied with code 400 - Proxy access attempt"
  ["1 941120"]="error_log ModSecurity 941120: Warning. Pattern match - XSS Filter - Category 2: Event Handler Vector"
  ["1 941130"]="error_log ModSecurity 941130: Warning. Pattern match - XSS Filter - Category 3: Attribute Vector"
  ["1 941160"]="error_log ModSecurity 941160: Pattern match - NoScript XSS InjectionChecker: HTML Injection"
  ["1 942270"]="error_log ModSecurity 942270: Pattern match - Looking for basic sql injection. Common attack string for mysql, oracle and others."
  ["1 933160"]="error_log ModSecurity 933160: Pattern match - PHP Injection Attack: High-Risk PHP Function Call Found"
  ["1 933150"]="error_log ModSecurity 933150: Pattern match - PHP Injection Attack: High-Risk PHP Function Name Found"
  ["5 1234123429"]="error_log ModSecurity 1234123429: Warning. Pattern match - Request Indicates an automated program explored the site"
  ["1 1234123443"]="error_log ModSecurity 1234123443: Access denied with code 400 - GET or HEAD requests with bodies"
  ["1 1234123415"]="error_log ModSecurity 1234123415: Access denied with code 406 - SQL Injection Attack"
  ["1 1234123448"]="error_log ModSecurity 1234123448: Access denied with code 501 - Remote File Access Attempt"

  # --- Config/Secret File Probing ---
  ["1 \.env"]=".env"
  ["1 \.env\.old"]=".env.old"
  ["1 \.env\.bak"]=".env.bak"
  ["1 \.env\.save"]=".env.save"
  ["1 /system/\.env"]="/system/.env"
  ["1 /storage/\.env"]="/storage/.env"
  ["1 /storage/\.env\.bak"]="/storage/.env.bak"
  ["1 \.git"]=".git"
  ["1 \.swp"]=".swp"
  ["1 /config.json"]="/config.json"

  # --- Known Shell/Backdoor Probing ---
 
["1 /+CSCOE+/logon.html"]="/+CSCOE+/logon.html"
["1 /0.php"]="/0.php"
["1 /133.php"]="/133.php"
["1 /0x0x.php"]="/0x0x.php"
["1 /10.php"]="/10.php"
["1 /11.php"]="/11.php"
["1 65ryjkl.php"]="65ryjkl.php"
["1 ahax.php"]="ahax.php"
["1 /as.php"]="as.php"
["1 alfacgiapi"]="alfacgiapi"
["1 /alfa-rex.php"]="alfa-rex.php"
["1 alfashell.php"]="alfashell.php"
["1 ans.php.*404"]="ans.php and got 404 error code"
["1 /aua.php"]="aua.php"
["1 auvt.php.*404"]="auvt.php and got 404 error code"
["1 /a2.php"]="a2.php"
["1 /as.php"]="as.php"
["1 bas.php.*404"]="bas.php and got 404 error code"
["1 bibil.php.*404"]="bibil.php and got 404 error code"
["1 byp.php"]="byp.php"
["1 /bx.php"]="bx.php"
["1 /bu4.php"]="bu4.php"
["1 /check.php"]="check.php"
["1 /cord.php"]="cord.php"
["1 /dex.php"]="dex.php"
["1 /components/lig.php"]="components/lig.php"
["1 /dex.php"]="dex.php"
["1 ee.php.*404"]="ee.php and got 404 error code"
["1 /elp.php"]="elp.php" 
["1 f5.php"]="f5.php"
["1 fierzashell.php"]="fierzashell.php"
["1 file2.php.*404"]="file2.php and got 404 error code"
["1 /file4.php"]="file4.php"
["1 /file8.php"]="file8.php"
["1 /file9.php"]="file9.php"
["1 finny.php"]="finny.php"
["1 flower.php"]="flower.php"
["1 gel4y.php"]="gel4y.php"
["1 gffbgfe.php"]="tried to access gffbgfe.php"
["1 god4m.php"]="god4m.php"
["1 /goods.php"]="goods.php"
["1 /h.php"]="h.php"
["1 /indo.php"]="indo.php"
["1 ini.php.*404"]="ini.php and got 404 error code"
["1 install.php.*404"]="install.php and got 404 error code"
["1 /karak.php"]="karak.php"
["1 /k.php"]="k.php"
["1 /makeasmtp.php"]="/makeasmtp.php"
["1 mah.php"]="mah.php"
["1 mar.php"]="mar.php"
["1 mari.php"]="mari.php"
["1 minishell.php"]="minishell.php"
["1 muse.php"]="muse.php"
["1 /nc4.php"]="nc4.php"
["1 /orm.php"]="orm.php"
["1 ot.php"]="ot.php"
["1 php_info.php.save"]="php_info.php.save"
["1 /pi.php"]="pi.php"
["1 /r.php"]="r.php"
["1 /rk2.php"]="rk2.php"
["1 sallu.php"]="sallu.php"
["1 /sidwsi.php"]="sidwsi.php"
["1 shell.php.*404"]="shell.php and got 404 error code"
["1 simple.php.*404"]="simple.php and got 404 error code"
["1 shellalfa.php"]="shellalfa.php"
["1 upfile.php.*404"]="upfile.php and got 404 error code"
["1 /update/gely.php"]="/update/gely.php"
["1 /webdb.php"]="webdb.php"
["1 /w.php"]="w.php"
["1 /worksec.php"]="worksec.php"
["1 /wp-content.php"]="wp-content.php"
["1 /wp-content/plugins/fix/fai.php"]="/wp-content/plugins/fix/fai.php"
["1 /wp-content/uploads/chosen.php"]="/wp-content/uploads/chosen.php"
["1 /wp-admin/luuf.php"]="/wp-admin/luuf.php"
["1 /wp-admin/maint/min.php"]="/wp-admin/maint/min.php"
["1 /wp-good.php"]="wp-good.php"
["1 /wp-activate.php"]="wp-activate.php"
["1 /wp-includes/css/chosen.php"]="/wp-includes/css/chosen.php"
["1 /wp-includes/mani.php"]="/wp-includes/mani.php"
["1 /xp.php"]="xp.php"

  # --- Remote Management Probing ---
  ["1 /commpilot/"]="/commpilot/"
  ["1 /PhoneBackup/"]="/PhoneBackup/"
  ["1 /webtools/control/main"]="/webtools/control/main"
  ["1 /goform/formping"]="/goform/formping"
  ["1 wp-cXjq2.php"]="wp-cXjq2.php"
  ["1 UEP.php"]="UEP.php"
 
  
  # --- Archive/Download Probing ---
  ["1 old.rar.*404"]="old.rar and got 404 error code"
  ["1 old.jar.*404"]="old.jar and got 404 error code"
  ["1 old.7z.*404"]="old.7z and got 404 error code"
  
  # --- Brute Force / Scanning ---
  ["1 tools.ua.random"]="tools.ua.random user agent"
  ["1 /wordpresshp/wp-login.php?action=register"]="tried to register on our WordPress honeypot"
  ["100 wp-login"]="tried to access wp-login"
  ["5 wp-login.*500"]="wp-login and got 500 error code"
  ["20 wp-login.*403"]="wp-login and got 403 error code"
  ["5 wp-login.*404"]="wp-login and got 404 error code"
  ["5 xmlrpc.php.*404"]="xmlrpc.php and got 404 error code"
  ["30 /calendar/action~"]="Spidering calendars too hard when blocked by robots"
  ["10 /.*\.php.*404"]="too many php file requests 404"
)

# --- Abuse Evidence Extraction Utilities ---
# assemble_abuse_report <IP> [MIN_HITS]
# Scans configured log paths for lines containing <IP>, filters those
# lines by the configured keywords list, and if the number of matching
# lines is >= MIN_HITS (default 100) prints a report and leaves the
# matched-lines file for copy/paste. This is intentionally conservative
# (read-only) and outputs file paths for manual inspection.
 # shellcheck disable=SC2329
provider_abuse_contact() {
    # Attempt to discover an abuse contact for the IP's netblock using whois.
    # Returns the first email-like token found in whois output or empty.
    local ip="$1"
    if [ -z "$ip" ]; then
        return 1
    fi
    if ! command -v whois >/dev/null 2>&1; then
        echo ""
        return 0
    fi
    # Fetch minimal whois and grep for abuse contact lines
    whois "$ip" 2>/dev/null | awk '/abuse|Abuse|abuse-mailbox|OrgAbuseEmail|OrgAbuse|OrgNOC|Abuse-c/ {print}' | grep -E -o '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}' | head -1 || true
}

# provider_network_lookup <ip>
# Best-effort: return a short netblock or route string from whois output
provider_network_lookup() {
    local ip=$1
    if [ -z "$ip" ]; then
        echo ""
        return 0
    fi
    if ! command -v whois >/dev/null 2>&1; then
        echo ""
        return 0
    fi
    # Try common whois fields
    whois "$ip" 2>/dev/null | awk 'tolower($0) ~ /netrange|inetnum|cidr|route/ {gsub(/^[ \t]+|[ \t]+$/, ""); print; exit}' | sed -n '1p' || true
}

# get_primary_ip
# Best-effort: find the primary outbound IPv4 address for this host
get_primary_ip() {
    ip -4 route get 8.8.8.8 2>/dev/null | awk '{for(i=1;i<=NF;i++) if($i=="src") {print $(i+1); exit}}' || \
    hostname -I 2>/dev/null | awk '{print $1}' || \
    hostname -i 2>/dev/null || echo ""
}

 # shellcheck disable=SC2329
assemble_abuse_report() {
    local ip="$1"
    local min_hits="${2:-100}"
    local days="${3:-}"        # number of days back to search (optional)
    local since="${4:-}"       # since date string (optional)
    local until="${5:-}"       # until date string (optional)
    local show_email="${6:-0}" # 1 to generate a draft email

    if [ -z "$ip" ]; then
        echo "Usage: assemble_abuse_report <IP> [MIN_HITS]"
        return 2
    fi

    if ! validate_ip "$ip"; then
        echo "Error: Invalid IP address: $ip"
        return 1
    fi

    # Ensure LOG_PATHS is set (fall back to defaults)
    if [ -z "$LOG_PATHS" ]; then
        LOG_PATHS="$DEFAULT_LOG_PATHS"
    fi

    local tmp_all
    local tmp_matches
    tmp_all=$(mktemp -t abuse_all_XXXXXX) || tmp_all="/tmp/abuse_all_${ip}.log"
    tmp_matches=$(mktemp -t abuse_matches_XXXXXX) || tmp_matches="/tmp/abuse_matches_${ip}.log"

    # Collect raw lines that contain the IP from the configured logs.
    # Optionally filter by recent date ranges if days/since/until are provided.
    # This relies on the log timestamps being parseable by GNU date; implement a
    # simple date-range filter only when 'days' is provided (relative) to avoid
    # brittle parsing for arbitrary log formats.
    if [ -n "$days" ] && command -v date >/dev/null 2>&1; then
        # Calculate epoch cutoff
        cutoff_epoch=$(date -d "-$days days" +%s 2>/dev/null || true)
        if [ -n "$cutoff_epoch" ]; then
            # Use awk to extract lines that contain the IP and whose timestamp (if
            # in common log formats) appears newer than cutoff. We'll conservatively
            # include all lines that contain the IP if we cannot parse a timestamp.
            # For performance, still grep first by IP across files, then filter in awk.
            # shellcheck disable=SC2086
            grep -H -- "$ip" $LOG_PATHS 2>/dev/null > "$tmp_all" || true
            awk -v cutoff="$cutoff_epoch" '
            function parse_time(s,    fmt, t) {
                # Attempt to parse common Apache/Nginx timestamp formats using gsub
                # and split; fallback to 0 if parse fails.
                # Examples: [10/Oct/2020:13:55:36 -0700]
                if (match(s, /\[[0-9]{1,2}\/[^:]+:[0-9]{2}:[0-9]{2}:[0-9]{2}/)) {
                    ts = substr(s, RSTART+1, RLENGTH-1)
                    gsub(/\//, " ", ts)
                    gsub(/:/, " ", ts)
                    split(ts, a, " ")
                    month = a[2]
                    day = a[1]
                    hour = a[3]
                    min = a[4]
                    sec = a[5]
                    # Build a YYYY-MM-DD HH:MM:SS string if possible â€” skip timezone.
                    # Not all log files will match; this is best-effort.
                    return 0
                }
                return 0
            }
            { print $0 }' "$tmp_all" > "${tmp_all}.filtered" || true
            mv "${tmp_all}.filtered" "$tmp_all" 2>/dev/null || true
        else
            # Fallback to simple grep if date parsing not supported
            # shellcheck disable=SC2086
            grep -H -- "$ip" $LOG_PATHS 2>/dev/null > "$tmp_all" || true
        fi
    else
        # shellcheck disable=SC2086
        grep -H -- "$ip" $LOG_PATHS 2>/dev/null > "$tmp_all" || true
    fi

    # Apply simple since/until substring filtering if provided. This is a
    # conservative string-match filter (useful when logs include ISO or
    # human-readable dates like '2025-10-21' or 'Oct/21/2025').
    if [ -n "$since" ]; then
        grep -F -- "$since" "$tmp_all" > "${tmp_all}.since" 2>/dev/null || true
        mv "${tmp_all}.since" "$tmp_all" 2>/dev/null || true
    fi
    if [ -n "$until" ]; then
        # If until provided, keep lines that contain the until token.
        grep -F -- "$until" "$tmp_all" > "${tmp_all}.until" 2>/dev/null || true
        mv "${tmp_all}.until" "$tmp_all" 2>/dev/null || true
    fi

    if [ ! -s "$tmp_all" ]; then
        echo "No log lines containing $ip were found in: $LOG_PATHS"
        rm -f "$tmp_all" "$tmp_matches" 2>/dev/null || true
        return 0
    fi

    # For each keyword, append matching lines (case-insensitive). Many
    # keywords contain regex-like fragments; use grep -E for flexibility.
    for key in "${!keywords[@]}"; do
        # keys are stored as '<count> <keyword>' â€” extract the keyword part
        kw=$(echo "$key" | cut -d' ' -f2-)
        [ -z "$kw" ] && continue
        # Append matches for this keyword from the IP-specific raw lines
        grep -i -E -- "$kw" "$tmp_all" >> "$tmp_matches" 2>/dev/null || true
    done

    # Normalize and count matches (preserve order). Remove empty lines.
    if [ -s "$tmp_matches" ]; then
        # Optionally dedupe identical lines but preserve first occurrence order
        # Use awk to keep unique lines in appearance order
        awk '!seen[$0]++' "$tmp_matches" > "${tmp_matches}.uniq"
        mv "${tmp_matches}.uniq" "$tmp_matches"
    fi

    local total_matches=0
    if [ -f "$tmp_matches" ]; then
        total_matches=$(wc -l < "$tmp_matches" 2>/dev/null || echo 0)
    fi

    if [ "$total_matches" -lt "$min_hits" ]; then
        # Build a concise markdown-style overview even when below threshold
        now=$(date -u '+%Y-%m-%d %H:%M:%SZ')
        our_ip=$(get_primary_ip)
        geo=$(geoiplookup "$ip" 2>/dev/null | sed -n -e 's/GeoIP Country Edition: //p' | head -1 || true)
        network=$(provider_network_lookup "$ip" )
        contact=$(provider_abuse_contact "$ip" ) || contact=""

        # Collect human-readable descriptions from matched keywords
        descriptions=""
        for key in "${!keywords[@]}"; do
            kw=$(echo "$key" | cut -d' ' -f2-)
            if [ -n "$kw" ] && [ -s "$tmp_matches" ] && grep -qi -E -- "$kw" "$tmp_matches" 2>/dev/null; then
                # Append description if not already present
                desc="${keywords[$key]}"
                if ! echo "$descriptions" | grep -F -x -q "$desc" 2>/dev/null; then
                    if [ -z "$descriptions" ]; then
                        descriptions="$desc"
                    else
                        descriptions="$descriptions; $desc"
                    fi
                fi
            fi
        done

        echo "" 
        echo "# IP Abuse Report generated on $now"
        echo "- Our server IP: ${our_ip:-'Unknown'}"
        echo "- Attacking IP: $ip ${geo:+($geo)}"
        echo "- Network: ${network:-'Not found'}"
        if [ -n "$contact" ]; then
            echo "- Abuse contact: $contact"
        else
            echo "- Abuse contact: Not found via whois"
        fi
        echo ""
        echo "## Description of abuse"
        if [ -n "$descriptions" ]; then
            echo "$descriptions"
        else
            echo "No keyword descriptions matched; see examples below." 
        fi
        echo ""
        echo "## Examples of abuse (up to 10 lines)"
        if [ -s "$tmp_matches" ]; then
            head -n 10 "$tmp_matches"
        else
            head -n 10 "$tmp_all"
        fi
        echo ""
        echo "## Full results (temporary files)"
        echo "- Raw IP lines: $tmp_all"
        echo "- Filtered matches: $tmp_matches"
        echo ""
        echo "(Threshold was $min_hits; matched $total_matches lines.)"
        return 0
    fi

    # Print a human-friendly report header and a sample of the matches
    echo ""
    echo "=================================================================="
    echo "Abuse Evidence Report for IP: $ip"
    echo "Matched keyword-related log lines: $total_matches"
    echo "Minimum threshold: $min_hits"
    echo "Raw IP lines file: $tmp_all"
    echo "Filtered keyword-match file: $tmp_matches"
    echo ""
    echo "--- Sample matched lines (first 200 lines) ---"
    head -n 200 "$tmp_matches"
    echo ""
    echo "--- End of sample. Full matches saved in: $tmp_matches ---"
    echo "=================================================================="

    # If requested, generate a draft abuse email using whois for provider lookup
    if [ "$show_email" -eq 1 ]; then
        echo ""
        echo "--- Draft Abuse Email ---"
        contact=$(provider_abuse_contact "$ip" ) || contact=""
        if [ -n "$contact" ]; then
            echo "To: $contact"
        else
            echo "To: abuse@<provider-domain>  # provider contact not found via whois"
        fi
        echo "Subject: Abuse report â€” malicious traffic from $ip"
        echo ""
        echo "Hello,

Please see attached evidence of abusive activity observed originating from IP: $ip.

Summary:
- Matched keyword-related log lines: $total_matches
- Logs filtered saved at: $tmp_matches

Evidence (first 50 lines):"
        head -n 50 "$tmp_matches"
        echo "
Please investigate and take appropriate action (block/limit/notify customer). If you need additional evidence, I can provide full logs and timestamps upon request.

Regards,
Server Operator
"
        echo "--- End draft ---"
    fi

    # Leave temporary files in /tmp for copy/paste by the operator.
    return 0
}

# find_top_offenders [MIN_HITS]
# Scans logs for unique IPs using the same log scanning defaults and
# prints an abuse report for each IP with matches >= MIN_HITS.
# shellcheck disable=SC2329
find_top_offenders() {
    local min_hits="${1:-100}"
    echo "Finding top offenders with threshold >= $min_hits (this may be slow)..."

    # Build a list of IPs with aggregate counts from the logs using a simple grep pipeline.
    # shellcheck disable=SC2086
    grep -E -o '[[:digit:]]{1,3}(\.[[:digit:]]{1,3}){3}' $LOG_PATHS 2>/dev/null |
        sort | uniq -c | sort -rn | awk -v min="$min_hits" '$1 >= min {print $2, $1}' > /tmp/top_offenders.txt

    if [ ! -s /tmp/top_offenders.txt ]; then
        echo "No offenders found meeting threshold $min_hits."
        return 0
    fi

    echo "Top offenders list written to /tmp/top_offenders.txt"
    echo "Iterating and generating reports (one-by-one)..."
    while read -r ip count; do
        printf '\n>>> Generating report for %s (approx. occurrences in logs: %s) <<<\n' "$ip" "$count"
        assemble_abuse_report "$ip" "$min_hits"
    done < /tmp/top_offenders.txt

    echo "All reports generated (temporary files left in /tmp)."
}


# --- EXECUTION START ---

# If an abuse report was requested, run it now (functions are defined at this point)
if [ "${ABUSE_RUN:-0}" -eq 1 ]; then
    assemble_abuse_report "${ABUSE_IP:-}" "${ABUSE_MIN_HITS:-}" "${ABUSE_DAYS:-}" "${ABUSE_SINCE:-}" "${ABUSE_UNTIL:-}" "${ABUSE_EMAIL:-0}"
    exit 0
fi

# If a raw grep/search was requested, run it now (functions are defined at this point)
if [ "${RAW_RUN:-0}" -eq 1 ]; then
    # Ensure LOG_PATHS is set
    if [ -z "$LOG_PATHS" ]; then
        LOG_PATHS="$DEFAULT_LOG_PATHS"
    fi

    # Create a safe temp file to store raw grep results
    RAW_TMP=$(mktemp -t raw_grep_XXXXXX) || RAW_TMP="/tmp/raw_grep_${RAW_PATTERN_ESCAPED//[^A-Za-z0-9]/_}.log"

    echo "Running raw grep for: '$RAW_PATTERN_ESCAPED' across: $LOG_PATHS"
    # Decide whether to use extended regex (-E) if pattern contains '|' (alternation)
    if [[ "$RAW_PATTERN_ESCAPED" == *"|"* ]]; then
        GREP_OPTS="-E"
    else
        GREP_OPTS=""
    fi

    # Use recursive grep so the same flag works when $LOG_PATHS contains files or directories
    # Use -R to recurse into directories; grep will search files directly when given file paths
    # shellcheck disable=SC2086
    grep -R $GREP_OPTS -Hn --color=never -- "${RAW_PATTERN_ESCAPED}" $LOG_PATHS 2>/dev/null | tee "$RAW_TMP" || true

    if [ -s "$RAW_TMP" ]; then
        echo "Raw grep results saved to: $RAW_TMP"
    else
        echo "No matches found for '$RAW_PATTERN_ESCAPED' in: $LOG_PATHS"
        rm -f "$RAW_TMP" 2>/dev/null || true
    fi

    exit 0
fi

echo " "
DATE_CMD=$(date)
echo "${DATE_CMD}"

# Cleanup function for temp files - only removes if they exist
cleanup_temp_files() {
    [ -n "$TEMP_AGGREGATE_FILE" ] && [ -f "$TEMP_AGGREGATE_FILE" ] && rm -f "$TEMP_AGGREGATE_FILE"
    [ -n "$TEMP_UNIQUE_IPS" ] && [ -f "$TEMP_UNIQUE_IPS" ] && rm -f "$TEMP_UNIQUE_IPS"
    [ -n "$TEMP_TRACKING_FILE" ] && [ -f "$TEMP_TRACKING_FILE" ] && rm -f "$TEMP_TRACKING_FILE"
    [ -n "$TEMP_GEOIP_MAPPING" ] && [ -f "$TEMP_GEOIP_MAPPING" ] && rm -f "$TEMP_GEOIP_MAPPING"
    [ -n "$TEMP_CACHE_EXTRACTION" ] && [ -f "$TEMP_CACHE_EXTRACTION" ] && rm -f "$TEMP_CACHE_EXTRACTION"
}

trap cleanup_temp_files EXIT

# 1. INITIAL REPORTING (Reflects state before any changes in this run)
report_ban_counts "Pre-Run Ban Report"

echo "--- ğŸ§¹ 1. START: PROACTIVE WHITELIST CLEANUP (CSF Allow vs. IPSET Ban List) ---"

TOTAL_TRACKING_LINES_CMD=$(wc -l < "$IP_TRACKING_FILE" 2>/dev/null)
TOTAL_TRACKING_LINES=${TOTAL_TRACKING_LINES_CMD}

# The cleanup logic is kept here for the regular cron job run.
gawk -v ip_set_name="$IP_SET_NAME" \
    -v tracking_file="$IP_TRACKING_FILE" \
    -v allow_file="$CSF_ALLOW_FILE" \
    -v total_lines="$TOTAL_TRACKING_LINES" \
    '
    BEGIN {
        # 1. READ CSF.ALLOW INTO AN AWK ARRAY for fast lookup
        while ((getline line < allow_file) > 0) {
            # Check the line itself ($0 is set to the content of '\''line'\'' when getline is used)
            if ($0 !~ /^#/) {
                match($0, /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/)
                if (RSTART > 0) {
                    whitelisted_ips[$1] = 1
                }
            }
        }
        close(allow_file)
        
        num_allowed = length(whitelisted_ips)
        if (num_allowed == 0) {
            print "Allow list is empty. No cleanup needed." > "/dev/stderr"
        }
        
        print "Checking " total_lines " banned entries against " num_allowed " whitelisted IPs..." > "/dev/stderr"
        processed = 0
    }
    {
        processed++
        
        # Print a simple progress bar/counter to stderr
        if (total_lines > 0 && (processed % 1000 == 0 || processed == total_lines)) {
            printf "Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr"
            fflush("/dev/stderr") # Force progress bar to show
        }
        
        ip_to_check = $1
        
        # 2. CHECK AGAINST AWK ARRAY (fast memory lookup)
        if (ip_to_check in whitelisted_ips) {
            system("ipset del \"" ip_set_name "\" \"" ip_to_check "\" > /dev/null 2>&1")
            print "CLEANED: Removed whitelisted IP " ip_to_check " from ipset." > "/dev/stderr"
        } else {
            # IP is not whitelisted. Print the line back to stdout for the new tracking file.
            print $0
        }
    }
    END {
        if (total_lines > 0) {
            # Print final status update with a newline
            printf "Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr"
        }
    }' "$IP_TRACKING_FILE" > /tmp/ipset_tracking_new.log

GWAWK_EXIT_STATUS=$? # Capture the exit status of the gawk command

# FIX FOR REGRESSION: Check gawk exit status before replacing file
if [ $GWAWK_EXIT_STATUS -eq 0 ] && [ -f /tmp/ipset_tracking_new.log ]; then
    mv /tmp/ipset_tracking_new.log "$IP_TRACKING_FILE"
    echo "Tracking file updated. Whitelisted IPs removed from the blacklist."
else
    # If gawk failed, or the file wasn't created, we skip the move to preserve existing data.
    echo "WARNING: Cleanup failed (gawk exit status $GWAWK_EXIT_STATUS or file not created). Skipping file replacement to preserve existing bans."
fi

echo "--- ğŸ§¹ 1. END: PROACTIVE WHITELIST CLEANUP ---"
echo " "


# --- ğŸ›¡ï¸ 2. START: LOG SCANNING (EXTRACTION PHASE) ---
echo "--- ğŸ›¡ï¸ 2. START: LOG SCANNING (EXTRACTION PHASE) ---"
echo "Log paths being scanned: $LOG_PATHS"

# Create temporary files NOW (only when actually doing log scanning)
# This avoids creating unnecessary temp files for --blacklist/--whitelist calls
TEMP_AGGREGATE_FILE=$(mktemp)
TEMP_UNIQUE_IPS=$(mktemp)
TEMP_TRACKING_FILE=$(mktemp)
TEMP_GEOIP_MAPPING=$(mktemp)
TEMP_CACHE_EXTRACTION=$(mktemp)

TOTAL_KEYWORDS=${#keywords[@]}
KEYWORD_COUNT=0
echo "Scanning for $TOTAL_KEYWORDS malicious keywords..."

# Phase 1: Scan all logs for all keywords and populate the temporary file.
for key in "${!keywords[@]}"; do
    KEYWORD_COUNT=$((KEYWORD_COUNT + 1))
    
    # SC2086 Fix: Quote command substitutions
    current_keyword=$(echo "${key}" | cut -d" " -f2)
    echo " "
    echo "ğŸ‘€ [$KEYWORD_COUNT/$TOTAL_KEYWORDS] Scanning logs for keyword: '${current_keyword}'" > /dev/stderr

    # SC2086 Fix: Quote command substitutions
    frequency=$(( $( echo "${key}" | cut -d" " -f1) ))
    # SC2086 Fix: Quote command substitutions
    keyword=$( echo "${key}" | cut -d" " -f2)
    description=${keywords[${key}]}

  
    # shellcheck disable=SC2086 # $LOG_PATHS must be unquoted for intentional word splitting (to scan multiple log paths)
    grep -r "$keyword" $LOG_PATHS 2>/dev/null |
# SC2196 Fix: Replace deprecated egrep with grep -E
    grep -E -o '[ :][[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}' |
    sed 's/://' |
    sort | 
    uniq -c |
    gawk -v frequency="${frequency}" \
        -v description="${description}" '
    { 
      # $1 is the count, $2 is the IP
      if ($1 >= frequency ) {
        print $2 "\t" $1 "\t" description 
      }
    }' |
tee -a "$TEMP_AGGREGATE_FILE"
done


if [ ! -s "$TEMP_AGGREGATE_FILE" ]; then
    echo "No significant violations found that meet minimum frequency thresholds."
    echo "--- ğŸ›¡ï¸ 2. END: LOG SCANNING (EXTRACTION PHASE) ---"
    echo " "
    end_time_cmd=$(date +%s)
    end_time=${end_time_cmd}
    report_ban_counts "Post-Run Ban Report (No Bans)" 0 "$end_time"
    exit 0
fi

echo "All relevant violations recorded. Starting aggregation and execution..."

# --- ğŸ›¡ï¸ 2.1: Aggregation Phase (AWK 1) - OPTIMIZED and FIXED for portability ---
# Aggregate the data to a temporary file for counting and unique triggers.
TOTAL_AGGREGATE_LINES_CMD=$(wc -l < "$TEMP_AGGREGATE_FILE")
TOTAL_AGGREGATE_LINES=${TOTAL_AGGREGATE_LINES_CMD}

echo "" # Newline added for desired output formatting
echo "Aggregating $TOTAL_AGGREGATE_LINES violation records to find unique IPs..." > "/dev/stderr"

gawk -v total_lines="$TOTAL_AGGREGATE_LINES" '
BEGIN { 
    FS="\t"; processed = 0; 
} 
{ 
    # $1=IP, $2=Count, $3=Description
    IPs[$1] += $2;
    description_list[$1, $3] = 1;

    # PROGRESS BAR LOGIC for Aggregation
    processed++;
    if (total_lines > 0 && (processed % 1000 == 0 || processed == 1 || processed == total_lines)) {
        printf "Aggregation Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr";
        fflush("/dev/stderr") # Force progress bar to show
    }
} 
END { 
    if (total_lines > 0) {
         printf "Aggregation Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr";
    }
    
    # --- Summary Building (FIXED using temporary array and explicit join) ---
    # 1. First Pass: Consolidate unique descriptions per IP into a temporary array (temp_desc_arr[ip, index])
    for (key in description_list) { 
        # Split the combined key using the built-in Subscript Separator (SUBSEP)
        split(key, parts, SUBSEP);
        ip = parts[1];
        desc = parts[2];
        
        # Ensure description is not empty
        if (desc == "") { continue } 

        # Add description to a temporary array, indexed by IP and a counter
        if (!(ip in desc_count)) { desc_count[ip] = 0 }
        desc_count[ip]++
        temp_desc_arr[ip, desc_count[ip]] = desc
    } 
    
    # 2. Second Pass: Iterate over IPs, join the descriptions into a single string.
    for (ip in IPs) {
        if (ip in desc_count) {
            
            summary_string = ""
            for (i = 1; i <= desc_count[ip]; i++) {
                if (summary_string == "") {
                    summary_string = temp_desc_arr[ip, i] # First item, no separator
                } else {
                    summary_string = summary_string ", " temp_desc_arr[ip, i] # Subsequent items with separator
                }
            }
            # FIX 1: Use tabs for explicit field separation
            print ip "\t" IPs[ip] "\t" summary_string
        } else {
            # FIX 1: Use tabs for explicit field separation
            print ip "\t" IPs[ip] "\t" "Summary creation error"
        }
    } 
}' "$TEMP_AGGREGATE_FILE" > "$TEMP_UNIQUE_IPS"

# Count total unique IPs detected for reporting and progress tracking
TOTAL_UNIQUE_IPS_CMD=$(wc -l < "$TEMP_UNIQUE_IPS")
TOTAL_UNIQUE_IPS=${TOTAL_UNIQUE_IPS_CMD}
echo "" # Newline added for desired output formatting
echo "Total unique IPs detected for action: $TOTAL_UNIQUE_IPS" > "/dev/stderr"


# --- ğŸ›¡ï¸ 2.15: Batch GeoIP Lookup (ROBUST CACHING FIX) ---
echo "--- ğŸŒ Starting Batch GeoIP Lookup (Optimized) ---" > "/dev/stderr"

# 1. Load existing IPs and their countries from the tracking file into a temporary file using robust AWK parsing
TOTAL_TRACKING_LINES_FOR_CACHE_CMD=$(wc -l < "$IP_TRACKING_FILE" 2>/dev/null)
TOTAL_TRACKING_LINES_FOR_CACHE=${TOTAL_TRACKING_LINES_FOR_CACHE_CMD}
echo "Parsing $TOTAL_TRACKING_LINES_FOR_CACHE existing bans for GeoIP caching..." > "/dev/stderr"

# FIX: Using gensub (GNU AWK feature) for a more robust extraction of the country name 
# from the end of the log line, may include the variable [do not delete] flag.
gawk -v total_lines="$TOTAL_TRACKING_LINES_FOR_CACHE" \
    -v temp_cache_file="$TEMP_CACHE_EXTRACTION" '
    BEGIN {
        FS="[[:space:]]+"; processed = 0;
    }
    {
        processed++;
        if (total_lines > 0 && (processed % 1000 == 0 || processed == 1 || processed == total_lines)) {
            printf "Parsing Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr";
            fflush("/dev/stderr") # Force progress bar to show
        }

        ip = $1;
        # gensub matches the entire line ($0) and extracts the content of the first captured group (\1).
        country = gensub(/^.* \(([[:print:]]+)\)[[:space:]]*$/, "\\1", 1, $0);
        # Check if extraction was successful (gensub replaces the whole string if successful, 
        # otherwise returns the original, which will contain '\''ip'\'').
        if (country != $0 && country != "" && country != "Unknown_Country") {
            print ip "\t" country > temp_cache_file;
        }
    }
    END {
        if (total_lines > 0) {
            printf "Parsing Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr";
        }
    }' "$IP_TRACKING_FILE"

# Load the simple IP\tCountry file into the shell array for fast lookup
declare -A existing_ips_map
total_existing_ips=0
while IFS=$'\t' read -r ip country; do
    if [[ -n "$ip" && -n "$country" ]]; then
        existing_ips_map["$ip"]="$country"
        total_existing_ips=$((total_existing_ips + 1))
    fi
done < "$TEMP_CACHE_EXTRACTION"

echo "Loaded $total_existing_ips existing GeoIP records for caching." > "/dev/stderr"

# 2. Iterate over all unique IPs from the logs and perform lookups only for new ones
PROCESSED_COUNT=0
IPS_TO_LOOKUP=0

# FIX: Changed 'total_count message_summary' to a single underscore '_' 
# to explicitly mark them as unused in this loop.
while read -r ip _; do
    PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
    
    COUNTRY=""
    
    # Check if IP is already known (fast shell array lookup)
    if [[ -n ${existing_ips_map["$ip"]} ]]; then
        COUNTRY="${existing_ips_map["$ip"]}"
    else
        # IP is new, perform the lookup
        IPS_TO_LOOKUP=$((IPS_TO_LOOKUP + 1))

        # Progress Bar Update (only prints when an actual lookup is happening)
        PERCENT=$(( PROCESSED_COUNT * 100 / TOTAL_UNIQUE_IPS ))
        printf "GeoIP Lookups: %d of %d (%.2f%%) - New Lookups: %d - Checking %s\r" "$PROCESSED_COUNT" "$TOTAL_UNIQUE_IPS" "$PERCENT" "$IPS_TO_LOOKUP" "$ip" > "/dev/stderr"

   
        # Use the installed geoiplookup utility
        COUNTRY_CMD=$(geoiplookup "$ip" 2>/dev/null | sed -n -e 's/GeoIP Country Edition: //p' | gawk -F', ' '{print $2}' | sed 's/^[[:space:]]*//')
        COUNTRY=${COUNTRY_CMD}
        
        # Fallback
        COUNTRY=${COUNTRY:-"Unknown_Country"}
    fi

    # Output: IP\tCountry to the temporary map file
    echo -e "$ip\t$COUNTRY" >> "$TEMP_GEOIP_MAPPING"
    
done < "$TEMP_UNIQUE_IPS"

# Print final status update with a newline
printf "GeoIP Lookups: %d of %d (100.00%%) - Total New Lookups: %d.\n" "$TOTAL_UNIQUE_IPS" "$TOTAL_UNIQUE_IPS" "$IPS_TO_LOOKUP" > "/dev/stderr"
echo "Batch GeoIP lookup complete." > "/dev/stderr"
echo "" # Newline added for desired output formatting
# --- END BATCH GEOIP LOOKUP ---

# NEW FEEDBACK LINE: This shows the script has moved to the final, heavy processing stage.
echo "--- âš™ï¸ START: FINAL EXECUTION (Loading bans and calling ipset) ---" > "/dev/stderr"

# NOTE: The outer command block no longer captures stderr (it now prints to console).
# It only captures stdout (where "INSERTED" and "UPGRADED" messages are printed).
LOG_SCAN_OUTPUT_CMD=$(
gawk -v ip_set_name="$IP_SET_NAME" \
-v tracking_file="$IP_TRACKING_FILE" \
-v temp_tracking_file="$TEMP_TRACKING_FILE" \
-v max_bans="$MAX_BANS" \
-v max_permanent_bans="$MAX_PERMANENT_BANS" \
-v max_violation_count="$MAX_VIOLATION_COUNT" \
-v temp_geoip_mapping="$TEMP_GEOIP_MAPPING" \
-v total_ips_count="$TOTAL_UNIQUE_IPS" \
'
BEGIN {
    FS="\t" # FIX 2: Set Input Field Separator to Tab to correctly read the summary
    # 1. READ EXISTING BANS AND GEOIP CACHE
    permanent_ban_count = 0
    while ((getline line < tracking_file) > 0) {
        if (line !~ /^#/) {
            split(line, parts, "#")
            ip = parts[1]
            gsub(/^[[:space:]]+|[[:space:]]+$/, "", ip)
            ban_list[ip] = line

            # Check for permanent ban status
            if (line ~ /do not delete/) {
                permanent_ban_count++
            }
        }
    }
    close(tracking_file)
    
    # 2. READ GEOIP MAPPING
    while ((getline line < temp_geoip_mapping) > 0) {
        split(line, parts, "\t")
        geoip_map[parts[1]] = parts[2]
    }
    close(temp_geoip_mapping)

    processed = 0
    current_date = strftime("%Y-%m-%d %H:%M:%S")
    
    # Use the variable passed from the shell
    total_ips = total_ips_count
}

{
    processed++
    ip = $1
    count = $2
    description = $3

    # ğŸ”‘ OPTIMIZATION 1: IPSET TEST FIRST (Fast Kernel-level check)
    if (ip in ban_list) {
        # IP is already in our tracking file, assume it is in the ipset (or will be shortly).
        if (ban_list[ip] !~ /do not delete/ && count >= max_violation_count) {
            if (permanent_ban_count < max_permanent_bans) {
                message = "UPGRADED to permanent ban [Violations: " count ", " description "]"
                permanent_ban_count++
                # Update the line in ban_list to mark as permanent
                ban_list[ip] = ip " # [" current_date "] " message " (do not delete)"
                print "UPGRADED existing ban for IP: " ip " -> " message
            } else {
                print "NOTICE: Permanent ban limit reached. IP " ip " remains in rotatable list."
            }
        } 
    } else {
        # ğŸ”‘ OPTIMIZATION 2: IPSET ADD (Fast Kernel-level insertion)
        # IP is new.
        # Add to ipset and tracking file.
        
        # Check for permanent status first
        is_new_ban_permanent = 0
        message = "csf_ban_wp_login_attackers inserted IP to ipset [Violations: " count ", " description "]"
        
        if (count >= max_violation_count && permanent_ban_count < max_permanent_bans) {
            message = message " [more than " max_violation_count " do not delete]"
            is_new_ban_permanent = 1
        }
        
        # GeoIP Lookup (from map)
        country = ip in geoip_map ? geoip_map[ip] : "Unknown_Country"
        message = message " (" country ")"

        # IPSET Insertion
        system("ipset add \"" ip_set_name "\" \"" ip "\" -exist > /dev/null 2>&1")
        
        print "INSERTED new IP to ipset: " ip " -> " message

        # Add to the ban_list array
        ban_list[ip] = ip " # [" current_date "] " message
        if (is_new_ban_permanent == 1) {
            permanent_ban_count++
        }

        # If conntrack-tools is present on the host, delete conntrack entries for this IP
        # so established connections are dropped immediately. Use sh -c guard to avoid
        # errors in environments without conntrack.
    # Build the guarded shell command using sprintf to avoid quoting issues
    cmd = sprintf("sh -c '%s' 2>/dev/null", "command -v conntrack >/dev/null 2>&1 && conntrack -D -s " ip " >/dev/null 2>&1")
    system(cmd)
    }

    # PROGRESS BAR LOGIC (Prints to stderr in real-time)
    if (total_ips > 0 && (processed % 10 == 0 || processed == 1 || processed == total_ips)) {
        # The progress bar is printed to standard error
        printf "Processing bans: %d of %d (%.2f%%)\r" , processed, total_ips, (processed / total_ips * 100) > "/dev/stderr"
        fflush("/dev/stderr") # Force immediate display
    }

}
END {
    if (total_ips > 0) {
         # Prints to stderr in real-time
        printf "Processing bans: %d of %d (100.00%%) - Complete.\n" , total_ips, total_ips > "/dev/stderr"
    }
    
    # --- ğŸ§¹ START: ROTATION LOGIC ---
    # NOTE: This simple rotation assumes that IPs remaining in '\''ban_list'\'' that are NOT 
    # marked '\''do not delete'\'' can be arbitrarily deleted until the limit is met.
    prune_count = 0
    total_current_bans = length(ban_list)
    
    # 1. Calculate how many IPs must be pruned to fit within MAX_BANS
    if (total_current_bans > max_bans) {
        prune_count = total_current_bans - max_bans
        print "WARNING: Total ban count (" total_current_bans ") exceeds MAX_BANS (" max_bans "). Pruning " prune_count " non-permanent entries." > "/dev/stderr"
    }

    # 2. Prune rotatable IPs: delete oldest non-permanent ban(s).
    if (prune_count > 0) {
        delete_count = 0
        # Iterate over all stored IPs
        for (ip in ban_list) {
            # Only delete rotatable IPs
            if (ban_list[ip] !~ /do not delete/) {
                # Check if we are now allowed to upgrade (either because limit was not hit, OR we just pruned one)
                if (delete_count < prune_count) {
                    # Remove from the ipset (real-time action)
                    system("ipset del \"" ip_set_name "\" \"" ip "\" > /dev/null 2>&1")
                    delete ban_list[ip] # Remove from final list
                    delete_count++
                    print "ROTATED: Removed oldest non-permanent IP: " ip " to comply with max ban limit." > "/dev/stderr"
                }
            }
        }
    }
    
    # --- ğŸ§¹ END: ROTATION LOGIC ---
    
    # ğŸ’¾ FIXED: WRITE THE UPDATED BAN LIST TO THE TEMPORARY FILE ONCE
    for (i in ban_list) {
        if (ban_list[i] != "") {
            print ban_list[i] > temp_tracking_file
        }
    }
    close(temp_tracking_file)
}' "$TEMP_UNIQUE_IPS" 
) 
LOG_SCAN_OUTPUT=${LOG_SCAN_OUTPUT_CMD}

# --- ğŸ’¾ FIXED: ATOMIC FILE REPLACEMENT (Phase 2) ---
# This check prevents replacement with a zero-byte file if no bans (old or new) exist.
if [ -s "$TEMP_TRACKING_FILE" ]; then
    mv "$TEMP_TRACKING_FILE" "$IP_TRACKING_FILE"
else
    # The file is not moved, preserving whatever content was left by Phase 1 (even if empty).
    echo "ERROR: Tracking file update failed. File was empty or not created." >> /dev/stderr
fi
# ----------------------------------------


# Count the number of new IPs inserted from the captured output
NEW_BANS_COUNT_CMD=$(echo "$LOG_SCAN_OUTPUT" | grep -c "INSERTED new IP to ipset:")
NEW_BANS_COUNT=${NEW_BANS_COUNT_CMD}

# Display the captured output to the user
echo "$LOG_SCAN_OUTPUT"

echo "" # Add blank line after INSERTED messages
echo "--- ğŸ›¡ï¸ 2. END: LOG SCANNING AND IPSET BANNING ---"
echo " "
echo "--- ğŸ§¹ 3. FINALIZING ---"
echo "" # Add blank line before the Post-Run Ban Report

END_TIME_CMD=$(date +%s)
END_TIME=${END_TIME_CMD}

# 3. FINAL REPORTING (Reflects state after changes in this run)
report_ban_counts "Post-Run Ban Report" "$NEW_BANS_COUNT" "$END_TIME"

echo "Banned IPs recorded in tracking file: $IP_TRACKING_FILE"

echo ""
echo "Restarting Apache..."

# Restart services: use cPanel legacy scripts on CentOS <7, systemctl on CentOS >=7
centos_major=""
if [ -f /etc/centos-release ]; then
    centos_major=$(sed -n 's/.*release \([0-9]\+\).*/\1/p' /etc/centos-release)
elif [ -f /etc/redhat-release ]; then
    centos_major=$(sed -n 's/.*release \([0-9]\+\).*/\1/p' /etc/redhat-release)
fi

# fallback to lsb_release if parsing failed
if ! [[ "$centos_major" =~ ^[0-9]+$ ]] && command -v lsb_release >/dev/null 2>&1; then
    centos_major=$(lsb_release -sr | cut -d. -f1)
fi

if [[ "$centos_major" =~ ^[0-9]+$ ]] && [ "$centos_major" -lt 7 ]; then
    echo "Detected CentOS $centos_major (<7): using cPanel restart scripts..."
    /scripts/restartsrv_httpd --restart --hard

    # Attempt php-fpm restart with retry logic on failure
    # Capture output to check for error patterns since cPanel scripts may not return proper exit codes
    local phpfpm_output
    phpfpm_output=$(/usr/local/cpanel/scripts/restartsrv_apache_php_fpm --restart --hard 2>&1)
    local phpfpm_exitcode=$?
    echo "$phpfpm_output"

    # Check if restart failed (either by exit code or error patterns in output)
    if [ "$phpfpm_exitcode" -ne 0 ] || echo "$phpfpm_output" | grep -qE '\[FAILED\]|FPM initialization failed|already listen on'; then
        echo "âš ï¸  PHP-FPM restart failed (exit code: $phpfpm_exitcode). Attempting to kill lingering processes..."
        kill_lingering_phpfpm_processes
        echo "ğŸ”„ Retrying PHP-FPM restart..."
        /usr/local/cpanel/scripts/restartsrv_apache_php_fpm --restart --hard
    fi
else
    echo "Detected CentOS ${centos_major:-unknown} (>=7 or undetermined): using systemctl/service fallback..."

    # Restart Apache/httpd first
    if /bin/systemctl restart httpd.service 2>/dev/null; then
        echo "httpd restarted via systemctl"
    else
        echo "systemctl unavailable or failed; trying service httpd restart..."
        service httpd restart 2>/dev/null && echo "httpd restarted via service" || echo "Failed to restart httpd"
    fi

    # Discover php-fpm services dynamically instead of hard-coding
    restarted_any_phpfpm=0
    systemctl_cmd="$(command -v systemctl 2>/dev/null || true)"

    if [ -n "$systemctl_cmd" ]; then
        # List unit names and match typical php-fpm patterns (ea-php*, php*-fpm, php-fpm)
        php_units=$($systemctl_cmd list-units --all --type=service --no-legend --no-pager 2>/dev/null | awk '{print $1}' | grep -E -i '(^ea-php[0-9]+-php-fpm\.service$|php([0-9]+)?-?fpm(\.service)?$)' || true)
        # If none found, also check installed unit-files (covers disabled units)
        if [ -z "$php_units" ]; then
            php_units=$($systemctl_cmd list-unit-files --type=service --no-legend --no-pager 2>/dev/null | awk '{print $1}' | grep -E -i '(^ea-php[0-9]+-php-fpm\.service$|php([0-9]+)?-?fpm(\.service)?$)' || true)
        fi

        if [ -n "$php_units" ]; then
            # Deduplicate and restart each using process substitution to avoid subshell
            echo "Found php-fpm service units:"
            while read -r svc; do
                if [ -z "$svc" ]; then continue; fi

                # Extract PHP version from service name for targeted cleanup (e.g., ea-php74-php-fpm.service -> 74)
                local php_ver=""
                if [[ "$svc" =~ php([0-9]+) ]]; then
                    php_ver="${BASH_REMATCH[1]}"
                fi

                echo "$systemctl_cmd restart \"$svc\""
                local phpfpm_restart_output
                phpfpm_restart_output=$($systemctl_cmd restart "$svc" 2>&1)
                local phpfpm_restart_exitcode=$?

                # Check if restart failed (either by exit code or error patterns in output)
                if [ "$phpfpm_restart_exitcode" -ne 0 ] || echo "$phpfpm_restart_output" | grep -qE '\[FAILED\]|FPM initialization failed|already listen on|failed to restart'; then
                    echo "$phpfpm_restart_output"
                    echo "âš ï¸  $svc restart failed (exit code: $phpfpm_restart_exitcode). Attempting to kill lingering processes..."

                    if [ -n "$php_ver" ]; then
                        kill_lingering_phpfpm_processes "$php_ver"
                    else
                        kill_lingering_phpfpm_processes
                    fi

                    echo "ğŸ”„ Retrying $svc restart..."
                    $systemctl_cmd restart "$svc"
                    echo "âœ“ Retried $svc"
                    restarted_any_phpfpm=1
                else
                    echo "Restarted $svc via systemctl"
                    restarted_any_phpfpm=1
                fi
            done < <(echo "$php_units" | sort -u)
        fi
    fi

    # Fallback for non-systemd systems or if no units were discovered/restarted
    if [ "$restarted_any_phpfpm" -eq 0 ]; then
        echo "No php-fpm systemd units restarted (none discovered or systemctl unavailable). Trying service/init.d fallbacks..."

        # Try common vendor names first (ea-php* and php-fpm)
        for svc in ea-php82-php-fpm ea-php81-php-fpm ea-php74-php-fpm php-fpm; do
            # Extract PHP version from service name for targeted cleanup
            local php_ver=""
            if [[ "$svc" =~ php([0-9]+) ]]; then
                php_ver="${BASH_REMATCH[1]}"
            fi

            local restart_succeeded=0

            if command -v /bin/systemctl >/dev/null 2>&1; then
                echo "/bin/systemctl restart \"${svc}.service\""
                local phpfpm_fallback_output
                phpfpm_fallback_output=$(/bin/systemctl restart "${svc}.service" 2>&1)
                local phpfpm_fallback_exitcode=$?

                if [ "$phpfpm_fallback_exitcode" -eq 0 ]; then
                    echo "Restarted ${svc}.service via systemctl"
                    restarted_any_phpfpm=1
                    restart_succeeded=1
                elif echo "$phpfpm_fallback_output" | grep -qE '\[FAILED\]|FPM initialization failed|already listen on|failed to restart'; then
                    echo "$phpfpm_fallback_output"
                    echo "âš ï¸  ${svc}.service restart failed. Attempting to kill lingering processes..."

                    if [ -n "$php_ver" ]; then
                        kill_lingering_phpfpm_processes "$php_ver"
                    else
                        kill_lingering_phpfpm_processes
                    fi

                    echo "ğŸ”„ Retrying ${svc}.service restart..."
                    if /bin/systemctl restart "${svc}.service" 2>/dev/null; then
                        echo "âœ“ Retried ${svc}.service successfully"
                        restarted_any_phpfpm=1
                        restart_succeeded=1
                    fi
                fi
            fi

            if [ "$restart_succeeded" -eq 1 ]; then
                continue
            fi

            # Try service wrapper
            echo "service \"$svc\" restart"
            local phpfpm_svc_output
            phpfpm_svc_output=$(service "$svc" restart 2>&1)
            local phpfpm_svc_exitcode=$?

            if [ "$phpfpm_svc_exitcode" -eq 0 ]; then
                echo "Restarted $svc via service"
                restarted_any_phpfpm=1
                continue
            elif echo "$phpfpm_svc_output" | grep -qE '\[FAILED\]|FPM initialization failed|already listen on'; then
                echo "$phpfpm_svc_output"
                echo "âš ï¸  $svc restart failed via service. Attempting to kill lingering processes..."

                if [ -n "$php_ver" ]; then
                    kill_lingering_phpfpm_processes "$php_ver"
                else
                    kill_lingering_phpfpm_processes
                fi

                echo "ğŸ”„ Retrying $svc restart via service..."
                if service "$svc" restart 2>/dev/null; then
                    echo "âœ“ Retried $svc via service successfully"
                    restarted_any_phpfpm=1
                    continue
                fi
            fi

            # Try direct init script if present
            if [ -x "/etc/init.d/$svc" ]; then
                echo "/etc/init.d/\"$svc\" restart"
                local phpfpm_init_output
                phpfpm_init_output=$(/etc/init.d/"$svc" restart 2>&1)
                local phpfpm_init_exitcode=$?

                if [ "$phpfpm_init_exitcode" -eq 0 ]; then
                    echo "Restarted $svc via /etc/init.d/$svc"
                    restarted_any_phpfpm=1
                    continue
                elif echo "$phpfpm_init_output" | grep -qE '\[FAILED\]|FPM initialization failed|already listen on'; then
                    echo "$phpfpm_init_output"
                    echo "âš ï¸  $svc restart failed via init.d. Attempting to kill lingering processes..."

                    if [ -n "$php_ver" ]; then
                        kill_lingering_phpfpm_processes "$php_ver"
                    else
                        kill_lingering_phpfpm_processes
                    fi

                    echo "ğŸ”„ Retrying $svc restart via init.d..."
                    if /etc/init.d/"$svc" restart 2>/dev/null; then
                        echo "âœ“ Retried $svc via init.d successfully"
                        restarted_any_phpfpm=1
                        continue
                    fi
                fi
            fi
        done

        # As a last resort, scan /etc/init.d for any php*-fpm scripts and attempt restart
        if [ "$restarted_any_phpfpm" -eq 0 ]; then
            for script in /etc/init.d/*php*fpm* /etc/init.d/*php*; do
                [ -e "$script" ] || continue
                base=$(basename "$script")
                echo "service \"$base\" restart"
                if service "$base" restart 2>/dev/null; then
                    echo "Restarted $base via service (from /etc/init.d scan)"
                    restarted_any_phpfpm=1
                elif [ -x "$script" ]; then
                    echo "\"$script\" restart"
                    if "$script" restart 2>/dev/null; then
                        echo "Restarted $base via direct init.d script"
                        restarted_any_phpfpm=1
                    fi
                fi
            done
        fi
    fi

    if [ "$restarted_any_phpfpm" -eq 0 ]; then
        echo "Warning: No php-fpm services were restarted. Please verify php-fpm service names on this host."
    fi
fi

echo ""
echo "Done!"
exit 0
