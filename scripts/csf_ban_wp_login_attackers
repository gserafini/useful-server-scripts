#!/bin/bash
# High-Performance IP Banning Script using IPSET and CSF.
# This script is designed for deployment via cron job to automate Web Application Firewall (WAF) 
# actions.
# It scans web server logs for a comprehensive set of malicious keywords and excessive 
# access attempts (e.g., failed wp-login, ModSecurity violations, shell file probing).
# It utilizes IPSET for high-capacity, kernel-level blocking and manages a persistent, 
# rotatable ban list synchronized with the CSF firewall rules via csfpost.sh.
#
# NOTE: This script is intended to be run with root privileges (e.g., via root's cron job) 
#       and no longer contains redundant 'sudo' calls.
# --- Author and Repository ---
# Author: Gabriel Serafini / gserafini@gmail.com
# Repository: https://github.com/gserafini/useful-server-scripts
# -----------------------------

# --- Command Line Options ---
# The script can be run with the following utility flags instead of its default log-scanning mode:
# 1. --init: Initializes the IPSET table and adds the necessary firewall rules to /etc/csf/csfpost.sh.
#    This must be run once before the cron job is activated.
# 2. --whitelist <IP>: Adds the specified IP address to /etc/csf/csf.allow, removes it from the 
#    IPSET ban list, and reloads CSF. (Requires setup)
# 3. --blacklist <IP>: Immediately adds the specified IP address to the IPSET ban list 
#    and the tracking file. It skips whitelisted IPs. (Requires setup)
# 4. --logs "<path1> <path2>": Overrides the default log paths to scan.
#    (Used in cron job or manual runs).
# 5. --clear: **DANGER** Flushes all IPs from the live IPSET table and clears the tracking file.
# ----------------------------

# --- Script Collaboration Credit ---
# This script was collaboratively developed and refined with Gemini Advanced.
# -----------------------------------

# --- CONFIGURATION VARIABLES ---
IP_SET_NAME="high_volume_bans"
IP_TRACKING_FILE="/etc/csf/ipset_tracking_${IP_SET_NAME}.log"
CSF_ALLOW_FILE="/etc/csf/csf.allow"
CSF_DENY_FILE="/etc/csf/csf.deny"
CSF_POST_FILE="/etc/csf/csfpost.sh" # Path to custom firewall rules
MAX_BANS=50000
MAX_PERMANENT_BANS=5000
MAX_VIOLATION_COUNT=20 # The threshold for permanent (do not delete) ban, based on aggregated hits.
# DEFAULT LOG FILES: These are used if no --logs argument is provided.
DEFAULT_LOG_PATHS="/usr/local/apache/logs/apache_mainlog /usr/local/apache/domlogs /usr/local/apache/logs/error_log"
LOG_PATHS="" 

# Temporary file for IP aggregation across all keywords
TEMP_AGGREGATE_FILE=$(mktemp)
# Temporary file for unique aggregated IPs 
TEMP_UNIQUE_IPS=$(mktemp)
# Temporary file for the new, complete tracking list
TEMP_TRACKING_FILE=$(mktemp)
# NEW: Temporary file to cache the IP -> Country map
TEMP_GEOIP_MAPPING=$(mktemp)
# NEW: Temporary file to hold the robustly extracted cache
TEMP_CACHE_EXTRACTION=$(mktemp)

# --- TIMING VARIABLE ---
START_TIME_CMD=$(date +%s)
START_TIME=${START_TIME_CMD}
# -------------------------------

# Function to safely validate an IP address format
validate_ip() {
    local ip=$1
    if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]];
    then
        return 0 
    else
        return 1 
    fi
}

# Function to determine the absolute path of iptables for rule generation
get_iptables_path() {
    local path
    local path_cmd
    
    path_cmd=$(command -v iptables 2>/dev/null || echo '/usr/sbin/iptables')
    path=${path_cmd}
    
    if [ ! -x "$path" ]; then
        
        path_cmd=$(command -v iptables 2>/dev/null || echo '/sbin/iptables')
        path=${path_cmd}
        
        if [ ! -x "$path" ]; then
            echo ""
            return 1
        fi
    fi
    echo "$path"
    return 0
}

# Function to check if the high-volume ban system is fully set up
is_setup_complete() {
    if [ ! -f "$IP_TRACKING_FILE" ]; then
        return 1
    fi
    if ! ipset list "$IP_SET_NAME" &> /dev/null; then
        return 1
    fi
    local iptables_path
    
    local path_cmd
    path_cmd=$(get_iptables_path)
    iptables_path=${path_cmd}
    
    if [ -z "$iptables_path" ];
    then
        return 1
    fi
    local iptables_rule_line="$iptables_path -A INPUT -m set --match-set $IP_SET_NAME src -j DROP"
    if [ ! -f "$CSF_POST_FILE" ] || ! grep -q "$iptables_rule_line" "$CSF_POST_FILE"; then
        return 1
    fi
    return 0
}

# Function to enforce setup or offer to initialize
ensure_setup() {
    if is_setup_complete;
    then
        return 0
    fi

    echo " "
    echo "====================================================================="
    echo "⚠️  CRITICAL SETUP WARNING"
    echo "====================================================================="
    echo "The High-Volume Ban system is not properly initialized."
    if [ -t 0 ]; then
        echo " "
        echo "Do you want to run the initialization (./csf_ban_wp_login_attackers --init) now?"
        read -r -p "Type 'yes' to initialize, or 'no' to exit: " response
        
        if [[ "$response" =~ ^[Yy][Ee][Ss]$ ]];
        then
            echo "Running initialization..."
            perform_init
        else
            echo "Initialization skipped. Exiting. Please run the script with the --init flag manually."
            exit 1
        fi
    else
        echo " "
        echo "ACTION REQUIRED: Run the script manually with the --init flag."
        echo "This script is running in a non-interactive environment (cron) and cannot proceed."
        exit 1
    fi
}


# Function to report the current ban counts
report_ban_counts() {
    local report_title="$1"
    local new_bans_count="${2:-0}"
    local end_time="${3:-0}" 
    echo "--- 📊 $report_title ---"
    
    local ipset_count_cmd
    ipset_count_cmd=$(grep -v '^\s*$' "$IP_TRACKING_FILE" 2>/dev/null | wc -l)
    local ipset_count=${ipset_count_cmd}

    local permanent_ban_count_cmd
    permanent_ban_count_cmd=$(grep -c "do not delete" "$IP_TRACKING_FILE" 2>/dev/null)
    local permanent_ban_count=${permanent_ban_count_cmd}

    local csf_deny_count_cmd
    csf_deny_count_cmd=$(grep -v '^#' "$CSF_DENY_FILE" 2>/dev/null | grep -v '^\s*$' | wc -l)
    local csf_deny_count=${csf_deny_count_cmd}


    echo "Total IPs in custom IPSET '$IP_SET_NAME': $ipset_count / $MAX_BANS"
    echo "Permanent IPs ('do not delete'): $permanent_ban_count / $MAX_PERMANENT_BANS"
    echo "Total IPs in CSF Deny File '$CSF_DENY_FILE': $csf_deny_count"
    
    if [ "$new_bans_count" -gt 0 ];
    then
        echo "New IPs added to blacklist: $new_bans_count"
    fi

    if [ "$end_time" -gt "$START_TIME" ];
    then
        local elapsed_time=$((end_time - START_TIME))
        local minutes=$((elapsed_time / 60))
        local seconds=$((elapsed_time % 60))
        echo "Total Elapsed Time: ${minutes}m ${seconds}s"
    fi
    
    echo "----------------------"
}

# Function to perform the blacklist action (Manual Ban)
perform_blacklist() {
    ensure_setup
    local ip=$1
    
    local timestamp_cmd
    timestamp_cmd=$(date "+%Y-%m-%d %H:%M:%S")
    local timestamp=${timestamp_cmd}
    local country=""

    echo "--- 🔴 Blacklist Action: $ip ---"

 
    if ! validate_ip "$ip"; then
        echo "Error: Invalid IP address format: $ip"
        exit 1
    fi

    # FIX: Use braces around simple variable to prevent SC2015 warning
    if grep -q "^${ip}[[:space:]]*" "$CSF_ALLOW_FILE";
    then
        echo "IP $ip is **WHITELISTED** in $CSF_ALLOW_FILE. Skipping blacklist action."
        exit 0
    fi

    if ipset test "$IP_SET_NAME" "$ip" &> /dev/null;
    then
        echo "IP $ip is already in ipset: $IP_SET_NAME. Skipping insertion."
        local end_time_cmd
        end_time_cmd=$(date +%s)
        local end_time=${end_time_cmd}
        report_ban_counts "Post-Blacklist Report" 0 "$end_time"
        exit 0
    fi
    
    # Use the same lookup method as the batch lookup for consistency
    local country_cmd
    country_cmd=$(geoiplookup "$ip" 2>/dev/null | sed -n -e 's/GeoIP Country Edition: //p' | gawk -F', ' '{print $2}' | sed 's/^[[:space:]]*//')
    country=${country_cmd}
    country=${country:-"Unknown_Country"}


    local message="Manually blacklisted via --blacklist"
    
    local current_ban_count_cmd
    current_ban_count_cmd=$(wc -l < "$IP_TRACKING_FILE")
    local current_ban_count=${current_ban_count_cmd}
  
    if [ "$current_ban_count" -ge "$MAX_BANS" ]; then
        echo "WARNING: Ban limit ($MAX_BANS) reached. IP $ip will be added, but the oldest rotatable IP will be removed on the next cron run."
    fi

    message="$message ($country)"

    if ipset add "$IP_SET_NAME" "$ip" -exist;
    then
        echo "Added $ip to ipset: $IP_SET_NAME."
    else
        echo "ERROR: Failed to add $ip to ipset. Check ipset utility and permissions."
        exit 1
    fi

    echo "$ip # [$timestamp] $message" |
    tee -a "$IP_TRACKING_FILE" > /dev/null
    echo "Added $ip to tracking file: $IP_TRACKING_FILE."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    report_ban_counts "Post-Blacklist Report" 1 "$end_time"
    exit 0
}

# Function to perform the whitelist action
perform_whitelist() {
    ensure_setup
    local ip=$1
    local timestamp_cmd
    timestamp_cmd=$(date "+%Y-%m-%d %H:%M:%S")
    local timestamp=${timestamp_cmd}
    local comment="# Added via script at $timestamp"

    echo "--- 🟢 Whitelist Action: $ip ---"

    # FIX: Use braces around simple variable to prevent SC2015 warning
    if ! grep -q "^${ip}[[:space:]]*" "$CSF_ALLOW_FILE"; then
        echo "$ip $comment" |
        tee -a "$CSF_ALLOW_FILE" > /dev/null
        echo "Added $ip to $CSF_ALLOW_FILE."
    else
        echo "$ip is already present in $CSF_ALLOW_FILE."
    fi

    if ipset test "$IP_SET_NAME" "$ip" &> /dev/null;
    then
        ipset del "$IP_SET_NAME" "$ip"
        echo "Removed $ip from ipset: $IP_SET_NAME."
    else
        echo "$ip was not found in ipset: $IP_SET_NAME (no action taken)."
    fi

    local line_number_cmd
    line_number_cmd=$(grep -n "^$ip " "$IP_TRACKING_FILE" 2>/dev/null | cut -d: -f1 | head -1)
    local line_number=${line_number_cmd}

    if [ -n "$line_number" ];
    then
        sed -i "${line_number}d" "$IP_TRACKING_FILE"
        echo "Removed $ip from tracking file: $IP_TRACKING_FILE (Line: $line_number)."
    else
        echo "$ip was not found in tracking file (no action taken)."
    fi

    echo "Reloading CSF to apply $CSF_ALLOW_FILE changes..."
    /usr/sbin/csf -r

    echo "Whitelist action complete for $ip."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    report_ban_counts "Post-Whitelist Report" 0 "$end_time"
    exit 0
}

# Function to initialize IPSET and CSF rules
perform_init() {
    local ip_set_line="ipset create $IP_SET_NAME hash:ip maxelem $MAX_BANS -exist"

    local iptables_path
    local path_cmd

    path_cmd=$(get_iptables_path)
    iptables_path=${path_cmd}
    
    if [ -z "$iptables_path" ];
    then
        echo "ERROR: Cannot find a valid path for the iptables executable. Initialization cannot proceed."
        exit 1
    fi
    local iptables_rule_line="$iptables_path -A INPUT -m set --match-set $IP_SET_NAME src -j DROP"

    echo "--- 🛠️ Initialization Action ---"

    echo "1. Creating IPSET table: $IP_SET_NAME with max size $MAX_BANS..."
    ipset create "$IP_SET_NAME" hash:ip maxelem "$MAX_BANS" -exist
    if [ $? -ne 0 ]; then
        echo "ERROR: Failed to create ipset '$IP_SET_NAME'. Check ipset utility and permissions."
        exit 1
    fi

    echo "2. Adding IPSET creation command to $CSF_POST_FILE..."
    if ! grep -q "$ip_set_line" "$CSF_POST_FILE"; then
        echo -e "\n# Rule added by $0 for high-volume IP banning\n$ip_set_line" |
        tee -a "$CSF_POST_FILE" > /dev/null
    fi

    echo "3. Adding portable iptables DROP rule ($iptables_path) for IPSET to $CSF_POST_FILE..."
    if ! grep -q "$iptables_rule_line" "$CSF_POST_FILE"; then
        echo "$iptables_rule_line" |
        tee -a "$CSF_POST_FILE" > /dev/null
    fi

    echo "4. Ensuring tracking file $IP_TRACKING_FILE exists..."
    touch "$IP_TRACKING_FILE" ||
    { echo "ERROR: Cannot create tracking file $IP_TRACKING_FILE"; exit 1;
    }

    echo "5. Reloading CSF to apply new rules..."
    /usr/sbin/csf -r
    
    echo "Initialization complete. The system is ready for the high-volume ban script to run."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    echo "Initialization run time: $((end_time - START_TIME))s" 
    exit 0
}

# Function to completely flush the IPSET and clear the tracking file
perform_clear() {
    ensure_setup
    
    echo " "
    echo "====================================================================="
    echo "⚠️  DANGER: FULL IPSET CLEAR ACTION"
    echo "====================================================================="
    
    if [ -t 0 ];
    then
        read -r -p "ARE YOU SURE you want to clear ALL $IP_SET_NAME bans? Type 'YES' to proceed: " response
        
        if [[ "$response" != "YES" ]];
        then
            echo "Clear action aborted by user. No changes were made."
            exit 0
        fi
    else
        echo "ERROR: --clear flag used in a non-interactive environment (cron/script)."
        exit 1
    fi
    
    echo "Proceeding with full IPSET flush and tracking file clear..."
    
    if ipset flush "$IP_SET_NAME";
    then
        echo "Successfully flushed all entries from ipset: $IP_SET_NAME."
    else
        echo "ERROR: Failed to flush ipset '$IP_SET_NAME'."
        exit 1
    fi
    
    if truncate -s 0 "$IP_TRACKING_FILE";
    then
        echo "Successfully cleared all content from tracking file: $IP_TRACKING_FILE."
    else
        true > "$IP_TRACKING_FILE"
        if [ $? -eq 0 ]; then
            echo "Successfully cleared all content from tracking file: $IP_TRACKING_FILE (using redirection)."
        else
            echo "ERROR: Failed to clear tracking file '$IP_TRACKING_FILE'."
            exit 1
        fi
    fi

    echo "IPSET '$IP_SET_NAME' is now empty. All prior bans are removed."
    local end_time_cmd
    end_time_cmd=$(date +%s)
    local end_time=${end_time_cmd}
    report_ban_counts "Post-Clear Report" 0 "$end_time"
    exit 0
}


# --- COMMAND LINE ARGUMENT PARSING ---
TEMP_ARGS_CMD=$(getopt -o '' --long init,whitelist:,blacklist:,logs:,clear -n 'csf_ban_wp_login_attackers' -- "$@")
TEMP_ARGS=${TEMP_ARGS_CMD}

if [ $? != 0 ]; then echo "Terminating..." >&2; exit 1; fi
eval set -- "$TEMP_ARGS"

while true;
do
  case "$1" in
    --init )
      perform_init
      ;;
    --whitelist )
      IP_TO_WHITELIST="$2"
      if [ -z "$IP_TO_WHITELIST" ] || ! validate_ip "$IP_TO_WHITELIST"; then
          echo "Error: --whitelist requires a valid IP address argument."
          exit 1
      fi
      perform_whitelist "$IP_TO_WHITELIST"
      ;;
    --blacklist )
      IP_TO_BLACKLIST="$2"
      if [ -z "$IP_TO_BLACKLIST" ] || ! validate_ip "$IP_TO_BLACKLIST"; then
          echo "Error: --blacklist requires a valid IP address argument."
          exit 1
      fi
      perform_blacklist "$IP_TO_BLACKLIST"
      ;;
    --logs )
      LOG_PATHS="$2"
      shift 2
      ;;
    --clear )
      perform_clear
      ;;
    -- )
      shift
      break
      ;;
    * )
      break
      ;;
  esac
done

if [ -z "$LOG_PATHS" ];
then
    LOG_PATHS="$DEFAULT_LOG_PATHS"
fi
# --- END ARGUMENT HANDLING ---

# 0. ENSURE SETUP IS COMPLETE FOR MAIN LOGIC
ensure_setup

# --- KEYWORDS CONFIGURATION ---
declare -A keywords
keywords=(
  # --- RCE / LFI / SQL Injection Payload Indicators (New) ---
  ["1 php://filter"]="attempted Local File Inclusion (LFI) using php://filter wrapper"
  ["1 /etc/passwd"]="attempted file traversal/read of /etc/passwd"
  ["1 etc/passwd"]="attempted LFI payload without leading slash"
  ["1 /proc/self/cmdline"]="attempted read of system process info"
  ["1 union select"]="attempted SQL injection with UNION SELECT clause"
  ["1 base64_decode"]="attempted RCE using base64 encoded payload"
  ["5 wso.php"]="attempted access to a WSO or similar PHP web shell"

 
  # --- ModSecurity Violations (High Frequency) ---
  ["5 AH01797"]="error_log ModSecurity AH01797: client denied by server configuration"
  ["5 AH10244"]="error_log ModSecurity AH10244: invalid URI path"
  ["5 AH01071"]="error_log ModSecurity AH01071: Got error Primary script unknown - requesting missing php file"
  ["1 1234123440"]="error_log ModSecurity 1234123440: Access denied with code 406 - URL Encoding Abuse Attack Attempt"
  ["1 1234123438"]="error_log ModSecurity 1234123438: Access denied with code 400 - Proxy access attempt"
  ["1 941120"]="error_log ModSecurity 941120: Warning. Pattern match - XSS Filter - Category 2: Event Handler Vector"
  ["1 941130"]="error_log ModSecurity 941130: Warning. Pattern match - XSS Filter - Category 3: Attribute Vector"
  ["1 941160"]="error_log ModSecurity 941160: Pattern match - NoScript XSS InjectionChecker: HTML Injection"
  ["1 942270"]="error_log ModSecurity 942270: Pattern match - Looking for basic sql injection. Common attack string for mysql, oracle and others."
  ["1 933160"]="error_log ModSecurity 933160: Pattern match - PHP Injection Attack: High-Risk PHP Function Call Found"
  ["1 933150"]="error_log ModSecurity 933150: Pattern match - PHP Injection Attack: High-Risk PHP Function Name Found"
  ["5 1234123429"]="error_log ModSecurity 1234123429: Warning. Pattern match - Request Indicates an automated program explored the site"
  ["1 1234123443"]="error_log ModSecurity 1234123443: Access denied with code 400 - GET or HEAD requests with bodies"
  ["1 1234123415"]="error_log ModSecurity 1234123415: Access denied with code 406 - SQL Injection Attack"
  ["1 1234123448"]="error_log ModSecurity 1234123448: Access denied with code 501 - Remote File Access Attempt"

  # --- Config/Secret File Probing ---
  ["1 \.env"]=".env"
  ["1 \.git"]=".git"
  ["1 \.swp"]=".swp"
  ["1 /config.json"]="/config.json"

  # --- Known Shell/Backdoor Probing ---
  ["1 /0.php"]="/0.php"
  ["1 /sidwsi.php"]="/sidwsi.php"
  ["1 /wp-includes/css/chosen.php"]="/wp-includes/css/chosen.php"
  ["1 /wp-admin/css/colors/install.php"]="/wp-admin/css/colors/install.php"
  ["1 /h.php"]="/h.php"
  ["1 /wp-includes/mani.php"]="/wp-includes/mani.php"
  ["1 /components/lig.php"]="/components/lig.php"
  ["1 /worksec.php"]="/worksec.php"
  ["1 /wp-content.php"]="/wp-content.php"
  ["1 /wp-admin/maint/min.php"]="/wp-admin/maint/min.php"
  ["1 /wp-content/uploads/chosen.php"]="/wp-content/uploads/chosen.php"
  ["1 /wp-content/plugins/fix/fai.php"]="/wp-content/plugins/fix/fai.php"
  ["1 /wp-admin/luuf.php"]="/wp-admin/luuf.php"
  ["1 /update/gely.php"]="/update/gely.php"
  ["1 alfacgiapi"]="alfacgiapi"
  ["1 shell.php.*404"]="shell.php and got 404 error code"
  ["1 upfile.php.*404"]="upfile.php and got 404 error code"
  ["1 mah.php"]="mah.php"
  ["1 /alfa-rex.php"]="/alfa-rex.php"
  ["1 minishell.php"]="minishell.php"
  ["1 alfashell.php"]="alfashell.php"
  ["1 mar.php"]="mar.php"
  ["1 /xp.php"]="/xp.php"
  ["1 /goods.php"]="/goods.php"
  ["1 /webdb.php"]="/webdb.php"
  ["1 byp.php"]="byp.php"
  ["1 file2.php.*404"]="file2.php and got 404 error code" 
  ["1 simple.php.*404"]="simple.php and got 404 error code"  
  ["1 bas.php.*404"]="bas.php and got 404 error code"
  ["1 bibil.php.*404"]="bibil.php and got 404 error code"
  ["1 auvt.php.*404"]="auvt.php and got 404 error code"
  ["1 ans.php.*404"]="ans.php and got 404 error code"
  ["1 0x.php.*404"]="0x.php and got 404 error code"
  ["1 gffbgfe.php"]="tried to access gffbgfe.php"
  ["1 install.php.*404"]="install.php and got 404 error code"
  ["1 ee.php.*404"]="ee.php and got 404 error code"
  ["1 /w.php"]="/w.php"
  ["1 /r.php"]="/r.php"
  ["1 /as.php"]="/as.php"
  ["1 ini.php.*404"]="ini.php and got 404 error code"
  ["1 /rk2.php"]="rk2.php"
  ["1 /bx.php"]="/bx.php"

  # --- Remote Management Probing ---
  ["1 /commpilot/"]="/commpilot/"
  ["1 /PhoneBackup/"]="/PhoneBackup/"
  ["1 /webtools/control/main"]="/webtools/control/main"
  ["1 /goform/formping"]="/goform/formping"
  ["1 wp-cXjq2.php"]="wp-cXjq2.php"
  ["1 UEP.php"]="UEP.php"
 
  
  # --- Archive/Download Probing ---
  ["1 old.rar.*404"]="old.rar and got 404 error code"
  ["1 old.jar.*404"]="old.jar and got 404 error code"
  ["1 old.7z.*404"]="old.7z and got 404 error code"
  
  # --- Brute Force / Scanning ---
  ["1 tools.ua.random"]="tools.ua.random user agent"
  ["1 /wordpresshp/wp-login.php?action=register"]="tried to register on our WordPress honeypot"
  ["100 wp-login"]="tried to access wp-login"
  ["5 wp-login.*500"]="wp-login and got 500 error code"
  ["20 wp-login.*403"]="wp-login and got 403 error code"
  ["5 wp-login.*404"]="wp-login and got 404 error code"
  ["5 xmlrpc.php.*404"]="xmlrpc.php and got 404 error code"
  ["30 /calendar/action~"]="Spidering calendars too hard when blocked by robots"
)

# --- EXECUTION START ---

echo " "
DATE_CMD=$(date)
echo "${DATE_CMD}"

trap 'rm -f "$TEMP_AGGREGATE_FILE" "$TEMP_UNIQUE_IPS" "$TEMP_TRACKING_FILE" "$TEMP_GEOIP_MAPPING" "$TEMP_CACHE_EXTRACTION"' EXIT

# 1. INITIAL REPORTING (Reflects state before any changes in this run)
report_ban_counts "Pre-Run Ban Report"

echo "--- 🧹 1. START: PROACTIVE WHITELIST CLEANUP (CSF Allow vs. IPSET Ban List) ---"

TOTAL_TRACKING_LINES_CMD=$(wc -l < "$IP_TRACKING_FILE" 2>/dev/null)
TOTAL_TRACKING_LINES=${TOTAL_TRACKING_LINES_CMD}

# The cleanup logic is kept here for the regular cron job run.
gawk -v ip_set_name="$IP_SET_NAME" \
    -v tracking_file="$IP_TRACKING_FILE" \
    -v allow_file="$CSF_ALLOW_FILE" \
    -v total_lines="$TOTAL_TRACKING_LINES" \
    '
    BEGIN {
        # 1. READ CSF.ALLOW INTO AN AWK ARRAY for fast lookup
        while ((getline line < allow_file) > 0) {
            # Check the line itself ($0 is set to the content of '\''line'\'' when getline is used)
         
            if ($0 !~ /^#/) {
                match($0, /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/)
    
                if (RSTART > 0) {
                    whitelisted_ips[$1] = 1
                }
            }
     
        }
        close(allow_file)
        
        
        num_allowed = length(whitelisted_ips)
        if (num_allowed == 0) {
            print "Allow list is empty. No cleanup needed." > "/dev/stderr"
        }
        
        print "Checking " total_lines " banned entries against " num_allowed " whitelisted IPs..." > "/dev/stderr"
        processed = 0
    }
    {
        processed++
        
        # Print a simple progress bar/counter to stderr
        if (total_lines > 0 && (processed % 1000 == 0 || processed == total_lines)) {
            printf "Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr"
            fflush("/dev/stderr") # Force progress bar to show
        }
        
        ip_to_check = $1
        
        # 2. CHECK AGAINST AWK ARRAY (fast memory lookup)
        if (ip_to_check in whitelisted_ips) {
 
 
            system("ipset del \"" ip_set_name "\" \"" ip_to_check "\" > /dev/null 2>&1")
            print "CLEANED: Removed whitelisted IP " ip_to_check " from ipset." > "/dev/stderr"
        } else {
            # IP is not whitelisted.
            # Print the line back to stdout for the new tracking file.
            print $0
        }
    }
    END {
        if (total_lines > 0) {
            # Print final status update with a newline
            printf "Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr"
        }
    }' "$IP_TRACKING_FILE" > /tmp/ipset_tracking_new.log

if [ -f /tmp/ipset_tracking_new.log ];
then
    mv /tmp/ipset_tracking_new.log "$IP_TRACKING_FILE"
    echo "Tracking file updated. Whitelisted IPs removed from the blacklist."
else
    echo "WARNING: Cleanup failed to produce a new tracking file. Skipping file replacement."
fi

echo "--- 🧹 1. END: PROACTIVE WHITELIST CLEANUP ---"
echo " "


# --- 🛡️ 2. START: LOG SCANNING (EXTRACTION PHASE) ---
echo "--- 🛡️ 2. START: LOG SCANNING (EXTRACTION PHASE) ---"
echo "Log paths being scanned: $LOG_PATHS"

TOTAL_KEYWORDS=${#keywords[@]}
KEYWORD_COUNT=0
echo "Scanning for $TOTAL_KEYWORDS malicious keywords..."

# Phase 1: Scan all logs for all keywords and populate the temporary file.
for key in "${!keywords[@]}"; do
    KEYWORD_COUNT=$((KEYWORD_COUNT + 1))
    
    # SC2086 Fix: Quote command substitutions
    current_keyword=$(echo "${key}" | cut -d" " -f2)
    echo "[$KEYWORD_COUNT/$TOTAL_KEYWORDS] Scanning logs for keyword: '${current_keyword}'" > /dev/stderr

    # SC2086 Fix: Quote command substitutions
    frequency=$(( $( echo "${key}" | cut -d" " -f1) ))
    # SC2086 Fix: Quote command substitutions
    keyword=$( echo "${key}" | cut -d" " -f2)
    description=${keywords[${key}]}

    # shellcheck disable=SC2086 # $LOG_PATHS must be unquoted for intentional word splitting (to scan multiple log paths)
    grep -r "$keyword" $LOG_PATHS 2>/dev/null |
    # SC2196 Fix: Replace deprecated egrep with grep -E
    grep -E -o '[ :][[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}' |
    sed 's/://' |
    sort | 
    uniq -c |
    gawk -v frequency="${frequency}" \
        -v description="${description}" '
    { 
      # $1 is the count, $2 is the IP
      if ($1 >= frequency ) {
        print $2 "\t" $1 "\t" description 
      }
    }' |
    tee -a "$TEMP_AGGREGATE_FILE"
done


if [ ! -s "$TEMP_AGGREGATE_FILE" ]; then
    echo "No significant violations found that meet minimum frequency thresholds."
    echo "--- 🛡️ 2. END: LOG SCANNING (EXTRACTION PHASE) ---"
    echo " "
    end_time_cmd=$(date +%s)
    end_time=${end_time_cmd}
    report_ban_counts "Post-Run Ban Report (No Bans)" 0 "$end_time"
    exit 0
fi

echo "All relevant violations recorded. Starting aggregation and execution..."

# --- 🛡️ 2.1: Aggregation Phase (AWK 1) - OPTIMIZED and FIXED for portability ---
# Aggregate the data to a temporary file for counting and unique triggers.
TOTAL_AGGREGATE_LINES_CMD=$(wc -l < "$TEMP_AGGREGATE_FILE")
TOTAL_AGGREGATE_LINES=${TOTAL_AGGREGATE_LINES_CMD}

echo "Aggregating $TOTAL_AGGREGATE_LINES violation records to find unique IPs..." > "/dev/stderr"

gawk -v total_lines="$TOTAL_AGGREGATE_LINES" '
BEGIN { 
    FS="\t";
    processed = 0; 
} 
{ 
    # $1=IP, $2=Count, $3=Description
    IPs[$1] += $2;
    # Portable single-dimension array with combined key
    description_list[$1, $3] = 1;

    # PROGRESS BAR LOGIC for Aggregation
    processed++;
    if (total_lines > 0 && (processed % 1000 == 0 || processed == 1 || processed == total_lines)) {
        printf "Aggregation Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr";
        fflush("/dev/stderr") # Force progress bar to show
    }
} 
END { 
    if (total_lines > 0) {
         printf "Aggregation Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr";
    }
    
    # --- Summary Building (FIXED using temporary array and explicit join) ---
    # 1. First Pass: Consolidate unique descriptions per IP into a temporary array (temp_desc_arr[ip, index])
    for (key in description_list) { 
        # Split the combined key using the built-in Subscript Separator (SUBSEP)
        split(key, parts, SUBSEP);
        ip = parts[1];
        desc = parts[2];
        
        # Ensure description is not empty
        if (desc == "") { continue } 

        # Add description to a temporary array, indexed by IP and a counter
        if (!(ip in desc_count)) { desc_count[ip] = 0 }
        desc_count[ip]++
        temp_desc_arr[ip, desc_count[ip]] = desc
    } 
    
    # 2. Second Pass: Iterate over IPs, join the descriptions into a single string.
    for (ip in IPs) {
        if (ip in desc_count) {
            
            summary_string = ""
            for (i = 1; i <= desc_count[ip]; i++) {
                if (summary_string == "") {
          
                    summary_string = temp_desc_arr[ip, i] # First item, no separator
                } else {
                    summary_string = summary_string ", " temp_desc_arr[ip, i] # Subsequent items with separator
                }
            }
     
            print ip, IPs[ip], summary_string
        } else {
            print ip, IPs[ip], "Summary creation error"
        }
    } 
}' "$TEMP_AGGREGATE_FILE" > "$TEMP_UNIQUE_IPS"

# Count total unique IPs detected for reporting and progress tracking
TOTAL_UNIQUE_IPS_CMD=$(wc -l < "$TEMP_UNIQUE_IPS")
TOTAL_UNIQUE_IPS=${TOTAL_UNIQUE_IPS_CMD}
echo "Total unique IPs detected for action: $TOTAL_UNIQUE_IPS" > "/dev/stderr"


# --- 🛡️ 2.15: Batch GeoIP Lookup (ROBUST CACHING FIX) ---
echo "--- 🌍 Starting Batch GeoIP Lookup (Optimized) ---" > /dev/stderr

# 1. Load existing IPs and their countries from the tracking file into a temporary file using robust AWK parsing
TOTAL_TRACKING_LINES_FOR_CACHE_CMD=$(wc -l < "$IP_TRACKING_FILE" 2>/dev/null)
TOTAL_TRACKING_LINES_FOR_CACHE=${TOTAL_TRACKING_LINES_FOR_CACHE_CMD}
echo "Parsing $TOTAL_TRACKING_LINES_FOR_CACHE existing bans for GeoIP caching..." > "/dev/stderr"

# FIX: Using gensub (GNU AWK feature) for a more robust extraction of the country name 
# from the end of the log line, may include the variable [do not delete] flag.
gawk -v total_lines="$TOTAL_TRACKING_LINES_FOR_CACHE" \
    -v temp_cache_file="$TEMP_CACHE_EXTRACTION" '
    BEGIN {
        FS="[[:space:]]+";
        processed = 0;
    }
    {
        processed++;
        if (total_lines > 0 && (processed % 1000 == 0 || processed == 1 || processed == total_lines)) {
            printf "Parsing Progress: %d of %d (%.2f%%)\r" , processed, total_lines, (processed / total_lines * 100) > "/dev/stderr";
            fflush("/dev/stderr") # Force progress bar to show
        }

        ip = $1;
        # gensub matches the entire line ($0) and extracts the content of the first captured group (\1).
        # Pattern: look for any characters (^.*), followed by a space, then the last '\''(\1)'\'' group, 
        # then optional trailing spaces ($).
        # [[:print:]]+ matches any printable character inside the parenthesis.
        country = gensub(/^.* \(([[:print:]]+)\)[[:space:]]*$/, "\\1", 1, $0);
        # Check if extraction was successful (gensub replaces the whole string if successful, 
        # otherwise returns the original, which will contain '\''ip'\'').
        if (country != $0 && country != "" && country != "Unknown_Country") {
            print ip "\t" country > temp_cache_file;
        }
    }
    END {
        if (total_lines > 0) {
            printf "Parsing Progress: %d of %d (100.00%%) - Complete.\n" , total_lines, total_lines > "/dev/stderr";
        }
    }' "$IP_TRACKING_FILE"

# Load the simple IP\tCountry file into the shell array for fast lookup
declare -A existing_ips_map
total_existing_ips=0
while IFS=$'\t' read -r ip country;
do
    if [[ -n "$ip" && -n "$country" ]];
    then
        existing_ips_map["$ip"]="$country"
        total_existing_ips=$((total_existing_ips + 1))
    fi
done < "$TEMP_CACHE_EXTRACTION"

echo "Loaded $total_existing_ips existing GeoIP records for caching." > "/dev/stderr"

# 2. Iterate over all unique IPs from the logs and perform lookups only for new ones
PROCESSED_COUNT=0
IPS_TO_LOOKUP=0

# FIX: Changed 'total_count message_summary' to a single underscore '_' 
# to explicitly mark them as unused in this loop.
while read -r ip _;
do
    PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
    
    COUNTRY=""
    
    # Check if IP is already known (fast shell array lookup)
    # FIX: Use braces when expanding arrays: ${existing_ips_map["$ip"]} (applied in previous step)
    if [[ -n ${existing_ips_map["$ip"]} ]];
    then
        COUNTRY="${existing_ips_map["$ip"]}"
    else
        # IP is new, perform the lookup
        IPS_TO_LOOKUP=$((IPS_TO_LOOKUP + 1))

        # Progress Bar Update (only prints when an actual lookup is happening)
        PERCENT=$(( PROCESSED_COUNT * 100 / TOTAL_UNIQUE_IPS ))
        printf "GeoIP Lookups: %d of %d (%.2f%%) - New Lookups: %d - Checking %s\r" "$PROCESSED_COUNT" "$TOTAL_UNIQUE_IPS" "$PERCENT" "$IPS_TO_LOOKUP" "$ip" > "/dev/stderr"

   
        # Use the installed geoiplookup utility
        COUNTRY_CMD=$(geoiplookup "$ip" 2>/dev/null | sed -n -e 's/GeoIP Country Edition: //p' | gawk -F', ' '{print $2}' | sed 's/^[[:space:]]*//')
        COUNTRY=${COUNTRY_CMD}
        
        # Fallback
        COUNTRY=${COUNTRY:-"Unknown_Country"}
    fi

    # Output: IP\tCountry to the temporary map file
    echo -e "$ip\t$COUNTRY" >> "$TEMP_GEOIP_MAPPING"
    
done < "$TEMP_UNIQUE_IPS"

# Print final status update with a newline
printf "GeoIP Lookups: %d of %d (100.00%%) - Total New Lookups: %d.\n" "$TOTAL_UNIQUE_IPS" "$TOTAL_UNIQUE_IPS" "$IPS_TO_LOOKUP" > "/dev/stderr"
echo "Batch GeoIP lookup complete." > "/dev/stderr"
# --- END BATCH GEOIP LOOKUP ---

# NEW FEEDBACK LINE: This shows the script has moved to the final, heavy processing stage.
echo "--- ⚙️ START: FINAL EXECUTION (Loading bans and calling ipset) ---" > /dev/stderr
LOG_SCAN_OUTPUT_CMD=$(
    gawk -v ip_set_name="$IP_SET_NAME" \
        -v tracking_file="$IP_TRACKING_FILE" \
        -v temp_tracking_file="$TEMP_TRACKING_FILE" \
        -v max_bans="$MAX_BANS" \
        -v max_permanent_bans="$MAX_PERMANENT_BANS" \
        -v max_violation_count="$MAX_VIOLATION_COUNT" \
        -v temp_geoip_mapping="$TEMP_GEOIP_MAPPING" \
        '
    BEGIN {
        # 1. READ EXISTING BANS AND GEOIP CACHE
        while ((getline line < tracking_file) > 0) {
            if (line !~ /^#/) {
                split(line, parts, "#")
                ip = parts[1]
                gsub(/^[[:space:]]+|[[:space:]]+$/, "", ip)
                ban_list[ip] = line

                # Check for permanent ban status
                if (line ~ /do not delete/) {
                    permanent_ban_count++
                }
            }
        }
        close(tracking_file)
        
        # 2. READ GEOIP MAPPING
        while ((getline line < temp_geoip_mapping) > 0) {
            split(line, parts, "\t")
            geoip_map[parts[1]] = parts[2]
        }
        close(temp_geoip_mapping)

        processed = 0
        current_date = strftime("%Y-%m-%d %H:%M:%S")
        total_ips = ARGC > 1 ? ARGC[1] : 0 
        
        print "Processing bans: 0 of " total_ips " (0.00%)" > "/dev/stderr"
    }
    {
        processed++
        ip = $1
        count = $2
        description = $3

        # 🔑 OPTIMIZATION 1: IPSET TEST FIRST (Fast Kernel-level check)
        if (ip in ban_list) {
            # IP is already in our tracking file, assume it is in the ipset (or will be shortly).
            # We still need to check if the new violation count meets the permanent threshold.
            
            if (ban_list[ip] !~ /do not delete/ && count >= max_violation_count) {
                if (permanent_ban_count < max_permanent_bans) {
                    message = "UPGRADED to permanent ban (Violations: " count ", " description ")"
                    permanent_ban_count++
                    
                    # Update the line in ban_list to mark as permanent
                    ban_list[ip] = ip " # [" current_date "] " message " (do not delete)"
                    print "UPGRADED existing ban for IP: " ip " -> " message
                } else {
                    print "NOTICE: Permanent ban limit reached. IP " ip " remains in rotatable list."
                }
            } else {
                # IP is already banned and status is not changing (either already permanent or still rotatable)
                print "SKIPPED IP already banned: " ip " (Violations: " count ")"
            }
        } else {
            # 🔑 OPTIMIZATION 2: IPSET ADD (Fast Kernel-level insertion)
            # IP is new. Add to ipset and tracking file.
            
            # Check for permanent status first
            is_new_ban_permanent = 0
            message = "INSERTED new IP to ipset (Violations: " count ", " description ")"
            
            if (count >= max_violation_count && permanent_ban_count < max_permanent_bans) {
                message = message " (do not delete)"
                is_new_ban_permanent = 1
            }
            
            # GeoIP Lookup (from map)
            country = ip in geoip_map ? geoip_map[ip] : "Unknown_Country"
            message = message " (" country ")"

            # IPSET Insertion
            system("ipset add \"" ip_set_name "\" \"" ip "\" -exist > /dev/null 2>&1")
            
            print "INSERTED new IP to ipset: " ip " -> " message

            # Add to the ban_list array
            ban_list[ip] = ip " # [" current_date "] " message
            if (is_new_ban_permanent == 1) {
                permanent_ban_count++
            }
        }

        # PROGRESS BAR LOGIC (Prints to stderr in real-time)
        if (total_ips > 0 && (processed % 10 == 0 || processed == 1 || processed == total_ips)) {
            printf "Processing bans: %d of %d (%.2f%%)\r" , processed, total_ips, (processed / total_ips * 100) > "/dev/stderr"
            fflush("/dev/stderr") # Force immediate display
        }
    }
    END {
        if (total_ips > 0) {
             # Prints to stderr in real-time
             printf "Processing bans: %d of %d (100.00%%) - Complete.\n" , total_ips, total_ips > "/dev/stderr"
        }
        
        # 💾 FIXED: WRITE THE UPDATED BAN LIST TO THE TEMPORARY FILE ONCE
        for (i in ban_list) {
            if (ban_list[i] != "") {
                print ban_list[i] > temp_tracking_file
            }
        }
        close(temp_tracking_file)
    }' "$TEMP_UNIQUE_IPS" 2>&1
)
LOG_SCAN_OUTPUT=${LOG_SCAN_OUTPUT_CMD}

# --- 💾 FIXED: ATOMIC FILE REPLACEMENT ---
if [ -s "$TEMP_TRACKING_FILE" ];
then
    mv "$TEMP_TRACKING_FILE" "$IP_TRACKING_FILE"
else
    # This error message is what you saw in the original output, now it is only printed if the file actually fails to update.
    echo "ERROR: Tracking file update failed. File was empty or not created." >> /dev/stderr
fi
# ----------------------------------------


# Count the number of new IPs inserted from the captured output
NEW_BANS_COUNT_CMD=$(echo "$LOG_SCAN_OUTPUT" | grep -c "INSERTED new IP to ipset:")
NEW_BANS_COUNT=${NEW_BANS_COUNT_CMD}

# Display the captured output to the user
echo "$LOG_SCAN_OUTPUT"

echo "--- 🛡️ 2. END: LOG SCANNING AND IPSET BANNING ---"
echo " "
echo "--- 🧹 3. FINALIZING ---"

END_TIME_CMD=$(date +%s)
END_TIME=${END_TIME_CMD}

# 3. FINAL REPORTING (Reflects state after changes in this run)
report_ban_counts "Post-Run Ban Report" "$NEW_BANS_COUNT" "$END_TIME"

echo "Banned IPs recorded in tracking file: $IP_TRACKING_FILE"

echo "Done!"
exit 0